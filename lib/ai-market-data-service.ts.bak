/**
 * AI Market Data Service
 * Fetches charts, graphs, and real-time data from the best sources
 * to assist users in making informed financial decisions
 */

import { enhancedMarketService } from './enhanced-market-service';
import { MarketAnalysisService } from './market-analysis-service';

export interface MarketDataResponse {
  text: string;
  charts?: ChartData[];
  data?: MarketMetrics;
  analysis?: string;
  sources?: string[];
}

export interface ChartData {
  type: 'line' | 'candlestick' | 'bar' | 'area' | 'comparison';
  title: string;
  symbol: string;
  data: any[];
  timeframe: string;
  embedUrl?: string;
}

export interface MarketMetrics {
  price: number;
  change24h: number;
  volume: number;
  marketCap?: string;
  high24h?: number;
  low24h?: number;
  sentiment?: 'bullish' | 'bearish' | 'neutral';
  technicalIndicators?: {
    rsi?: number;
    macd?: string;
    movingAverage?: string;
  };
}

export class AIMarketDataService {
  /**
   * Fetch technical indicator chart for an asset
   */
  static async fetchTechnicalIndicator(symbol: string, indicator: string): Promise<MarketDataResponse> {
    try {
      // Fetch real-time price and market data
      const assetData = await enhancedMarketService.fetchAssetPrice(symbol);
      
      if (!assetData) {
        return {
          text: `‚ö†Ô∏è I couldn't find data for ${symbol}. Please verify the symbol and try again.`,
          sources: []
        };
      }

      // Detect asset type
      const assetType = this.detectAssetType(symbol);

      // Map indicator name to description
      const indicatorInfo: Record<string, { name: string; description: string; interpretation: string }> = {
        'RSI': {
          name: 'Relative Strength Index (RSI)',
          description: 'Measures momentum on a scale of 0-100',
          interpretation: 'RSI > 70 suggests overbought conditions (potential reversal down), RSI < 30 suggests oversold conditions (potential reversal up)'
        },
        'MACD': {
          name: 'Moving Average Convergence Divergence (MACD)',
          description: 'Shows the relationship between two moving averages',
          interpretation: 'MACD crossing above signal line is bullish, crossing below is bearish'
        },
        'BB': {
          name: 'Bollinger Bands',
          description: 'Shows price volatility and potential breakout zones',
          interpretation: 'Price touching upper band suggests overbought, touching lower band suggests oversold'
        }
      };

      const info = indicatorInfo[indicator] || indicatorInfo['RSI'];
      
      const changeEmoji = assetData.change24h >= 0 ? 'üü¢' : 'üî¥';
      const changeSign = assetData.change24h >= 0 ? '+' : '';

      let text = `üìä **${info.name} Chart for ${assetData.name} ${symbol}**\n\n`;
      text += `üí∞ **Current Price**: $${assetData.currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}\n`;
      
      if (assetData.change24h !== undefined) {
        text += `${changeEmoji} **24h Change**: ${changeSign}${assetData.change24h.toFixed(2)}%\n`;
      }

      text += `\nüìà **About ${info.name}**:\n${info.description}\n\n`;
      text += `üí° **How to Read It**:\n${info.interpretation}\n\n`;
      text += `üîç Click the link below to view the interactive ${info.name} chart on TradingView.`;

      // Generate TradingView widget URL with indicator
      const tradingViewUrl = this.generateTradingViewUrlWithIndicator(symbol, assetType, indicator);

      const response: MarketDataResponse = {
        text,
        charts: [
          {
            type: 'line',
            title: `${assetData.name} ${symbol} ${info.name}`,
            symbol: symbol,
            data: [],
            timeframe: '24h',
            embedUrl: tradingViewUrl
          }
        ],
        data: {
          price: assetData.currentPrice,
          change24h: assetData.change24h || 0,
          volume: 0,
          marketCap: assetData.marketCap,
        },
        sources: [...this.getSources(assetType), 'TradingView Technical Analysis']
      };

      return response;
    } catch (error) {
      console.error('Error fetching technical indicator:', error);
      return {
        text: `‚ùå I encountered an error fetching the ${indicator} chart for ${symbol}. Please try again.`,
        sources: []
      };
    }
  }

  /**
   * Fetch comprehensive market data for an asset
   */
  static async fetchAssetInsights(symbol: string, type?: 'crypto' | 'stock'): Promise<MarketDataResponse> {
    try {
      // Fetch real-time price and market data
      const assetData = await enhancedMarketService.fetchAssetPrice(symbol, type);
      
      if (!assetData) {
        return {
          text: `‚ö†Ô∏è I couldn't find data for ${symbol}. Please verify the symbol and try again.`,
          sources: []
        };
      }

      // Detect asset type if not specified
      const assetType = type || this.detectAssetType(symbol);

      // Get market analysis
      let analysis = '';
      let technicalData: any = {};

      if (assetType === 'crypto') {
        const cryptoAnalysis = MarketAnalysisService.getCryptoAnalysis();
        analysis = cryptoAnalysis.recommendation || '';
        
        // Find if this crypto is in top performers
        const topPerformer = cryptoAnalysis.topPerformers?.find(
          (p: any) => p.symbol === symbol
        );
        if (topPerformer) {
          analysis += `\n\nüìà **${symbol}** is currently a top performer with ${topPerformer.change} change.`;
        }
      } else if (assetType === 'stock') {
        const stockAnalysis = MarketAnalysisService.getStockAnalysis();
        analysis = stockAnalysis.recommendation || '';
        technicalData = {
          volatility: stockAnalysis.marketOverview?.volatility,
        };
      }

      // Generate TradingView widget URL
      const tradingViewUrl = this.generateTradingViewUrl(symbol, assetType);

      const response: MarketDataResponse = {
        text: this.generateInsightText(assetData, assetType, analysis),
        charts: [
          {
            type: 'line',
            title: `${assetData.name} ${symbol} Price Chart`,
            symbol: symbol,
            data: [],
            timeframe: '24h',
            embedUrl: tradingViewUrl
          }
        ],
        data: {
          price: assetData.currentPrice,
          change24h: assetData.change24h || 0,
          volume: 0, // Would come from API
          marketCap: assetData.marketCap,
          ...technicalData
        },
        analysis,
        sources: this.getSources(assetType)
      };

      return response;
    } catch (error) {
      console.error('Error fetching asset insights:', error);
      return {
        text: `‚ùå I encountered an error fetching data for ${symbol}. Please try again.`,
        sources: []
      };
    }
  }

  /**
   * Compare multiple assets side-by-side
   */
  static async compareAssets(symbols: string[]): Promise<MarketDataResponse> {
    try {
      const assetDataPromises = symbols.map(symbol => 
        enhancedMarketService.fetchAssetPrice(symbol)
      );
      
      const assetsData = await Promise.all(assetDataPromises);
      const validAssets = assetsData.filter(a => a !== null);

      if (validAssets.length === 0) {
        return {
          text: "‚ö†Ô∏è I couldn't find data for any of those symbols. Please check and try again.",
          sources: []
        };
      }

      // Generate comparison text
      let comparisonText = `üìä **Asset Comparison**\n\n`;
      
      validAssets.forEach(asset => {
        const changeEmoji = asset.change24h >= 0 ? 'üü¢' : 'üî¥';
        const changeSign = asset.change24h >= 0 ? '+' : '';
        comparisonText += `**${asset.name} ${asset.symbol}**\n`;
        comparisonText += `üí∞ Price: $${asset.currentPrice.toFixed(2)}\n`;
        comparisonText += `${changeEmoji} 24h: ${changeSign}${asset.change24h?.toFixed(2)}%\n`;
        if (asset.marketCap) {
          comparisonText += `üìä Market Cap: ${asset.marketCap}\n`;
        }
        comparisonText += `\n`;
      });

      // Analysis
      const bestPerformer = validAssets.reduce((best, current) => 
        (current.change24h || 0) > (best.change24h || 0) ? current : best
      );

      comparisonText += `\nüèÜ **Best 24h Performer**: ${bestPerformer.name} with ${bestPerformer.change24h >= 0 ? '+' : ''}${bestPerformer.change24h?.toFixed(2)}%`;

      return {
        text: comparisonText,
        charts: validAssets.map(asset => ({
          type: 'line' as const,
          title: `${asset.name} ${asset.symbol}`,
          symbol: asset.symbol,
          data: [],
          timeframe: '24h',
          embedUrl: this.generateTradingViewUrl(asset.symbol, this.detectAssetType(asset.symbol))
        })),
        sources: ['CoinGecko API', 'Yahoo Finance', 'TradingView Charts']
      };
    } catch (error) {
      console.error('Error comparing assets:', error);
      return {
        text: "‚ùå I encountered an error comparing these assets. Please try again.",
        sources: []
      };
    }
  }

  /**
   * Get market sentiment and trends
   */
  static async getMarketSentiment(category: 'crypto' | 'stock' | 'overall'): Promise<MarketDataResponse> {
    try {
      let analysis: any;
      let text = '';

      if (category === 'crypto') {
        analysis = MarketAnalysisService.getCryptoAnalysis();
        text = `ü™ô **Cryptocurrency Market Sentiment**\n\n`;
        text += `üìä **Overall Market**: ${analysis.marketSentiment || 'Neutral'}\n`;
        text += `‚ö° **Dominance**: BTC ${analysis.btcDominance}, ETH ${analysis.ethDominance}\n\n`;
        
        text += `üî• **Top Performers (24h):**\n`;
        analysis.topPerformers?.forEach((crypto: any) => {
          const emoji = crypto.change?.startsWith('+') ? 'üü¢' : 'üî¥';
          text += `${emoji} **${crypto.symbol}**: ${crypto.change}\n`;
        });

        text += `\nüí° **Recommendation**: ${analysis.recommendation}`;
      } else if (category === 'stock') {
        analysis = MarketAnalysisService.getStockAnalysis();
        text = `üìà **Stock Market Sentiment**\n\n`;
        text += `üìä **Market Overview:**\n`;
        text += `‚Ä¢ **S&P 500**: ${analysis.marketOverview?.sp500?.change || 'N/A'}\n`;
        text += `‚Ä¢ **Volatility (VIX)**: ${analysis.marketVolatility || 'N/A'}\n`;
        text += `‚Ä¢ **Sentiment**: ${analysis.sentiment || 'Neutral'}\n\n`;
        
        text += `üè≠ **Sector Performance:**\n`;
        Object.entries(analysis.sectors || {}).forEach(([sector, data]: [string, any]) => {
          const emoji = data.performance?.startsWith('+') ? 'üü¢' : 'üî¥';
          text += `${emoji} **${sector}**: ${data.performance} (${data.outlook})\n`;
        });

        text += `\nüí° **Recommendation**: ${analysis.recommendation}`;
      } else {
        // Overall market
        const stockAnalysis = MarketAnalysisService.getStockAnalysis();
        const cryptoAnalysis = MarketAnalysisService.getCryptoAnalysis();
        const portfolioAnalysis = MarketAnalysisService.getPortfolioAnalysis();

        text = `üåç **Overall Market Sentiment**\n\n`;
        text += `üìà **Stocks**: Moderate Volatility\n`;
        text += `ü™ô **Crypto**: ${cryptoAnalysis.marketSentiment || 'Neutral'}\n`;
        text += `üìä **Risk Level**: Moderate\n\n`;
        text += `üí° **Key Insight**: ${portfolioAnalysis.diversificationScore || 'Maintain a diversified portfolio across asset classes.'}`;
      }

      return {
        text,
        analysis: analysis.recommendation,
        sources: this.getSources(category)
      };
    } catch (error) {
      console.error('Error getting market sentiment:', error);
      return {
        text: "‚ùå I encountered an error fetching market sentiment. Please try again.",
        sources: []
      };
    }
  }

  /**
   * Analyze portfolio performance
   */
  static async analyzePortfolio(holdings: any[]): Promise<MarketDataResponse> {
    try {
      if (!holdings || holdings.length === 0) {
        return {
          text: "üìä You don't have any holdings to analyze yet. Add some assets to get started!",
          sources: []
        };
      }

      let totalValue = 0;
      let totalGainLoss = 0;
      const assetPerformance: any[] = [];

      // Fetch current prices for all holdings
      for (const holding of holdings) {
        const currentData = await enhancedMarketService.fetchAssetPrice(holding.symbol);
        if (currentData) {
          const amount = holding.amount || holding.shares || 0;
          const entryPrice = holding.entryPoint || holding.entryPrice || 0;
          const currentValue = amount * currentData.currentPrice;
          const costBasis = amount * entryPrice;
          const gainLoss = currentValue - costBasis;
          const gainLossPercent = (gainLoss / costBasis) * 100;

          totalValue += currentValue;
          totalGainLoss += gainLoss;

          assetPerformance.push({
            symbol: holding.symbol,
            name: currentData.name,
            currentValue,
            gainLoss,
            gainLossPercent,
            currentPrice: currentData.currentPrice
          });
        }
      }

      // Sort by performance
      assetPerformance.sort((a, b) => b.gainLossPercent - a.gainLossPercent);

      const totalGainLossPercent = holdings.reduce((sum, h) => {
        const amount = h.amount || h.shares || 0;
        return sum + (amount * (h.entryPoint || h.entryPrice || 0));
      }, 0);

      const finalGainLossPercent = (totalGainLoss / totalGainLossPercent) * 100;

      let text = `üìä **Portfolio Performance Analysis**\n\n`;
      text += `üí∞ **Total Portfolio Value**: $${totalValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}\n`;
      
      const gainEmoji = totalGainLoss >= 0 ? 'üü¢' : 'üî¥';
      text += `${gainEmoji} **Total P/L**: ${totalGainLoss >= 0 ? '+' : ''}$${totalGainLoss.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} (${finalGainLossPercent >= 0 ? '+' : ''}${finalGainLossPercent.toFixed(2)}%)\n\n`;

      text += `üèÜ **Top Performers:**\n`;
      assetPerformance.slice(0, 3).forEach((asset, idx) => {
        const emoji = asset.gainLoss >= 0 ? 'üü¢' : 'üî¥';
        text += `${idx + 1}. ${emoji} **${asset.symbol}**: ${asset.gainLoss >= 0 ? '+' : ''}${asset.gainLossPercent.toFixed(2)}%\n`;
      });

      if (assetPerformance.length > 3) {
        text += `\nüìâ **Underperformers:**\n`;
        assetPerformance.slice(-2).forEach((asset) => {
          const emoji = asset.gainLoss >= 0 ? 'üü¢' : 'üî¥';
          text += `${emoji} **${asset.symbol}**: ${asset.gainLoss >= 0 ? '+' : ''}${asset.gainLossPercent.toFixed(2)}%\n`;
        });
      }

      // Get portfolio-level analysis
      const portfolioAnalysis = MarketAnalysisService.getPortfolioAnalysis();
      text += `\nüí° **Recommendation**: Maintain diversification and monitor market conditions`;

      return {
        text,
        data: {
          price: totalValue,
          change24h: finalGainLossPercent,
          volume: 0
        },
        analysis: 'Portfolio showing balanced risk-reward profile',
        sources: ['Live Market Data', 'Portfolio Analytics']
      };
    } catch (error) {
      console.error('Error analyzing portfolio:', error);
      return {
        text: "‚ùå I encountered an error analyzing your portfolio. Please try again.",
        sources: []
      };
    }
  }

  /**
   * Generate TradingView widget URL with specific technical indicator
   */
  private static generateTradingViewUrlWithIndicator(symbol: string, type: 'crypto' | 'stock', indicator: string): string {
    const baseUrl = 'https://www.tradingview.com/widgetembed/';
    
    // Map symbol to TradingView format
    let tvSymbol = symbol.toUpperCase();
    if (type === 'crypto') {
      tvSymbol = `BINANCE:${symbol}USDT`;
    } else {
      // Most US stocks
      tvSymbol = `NASDAQ:${symbol}`;
    }

    // Map indicator to TradingView study ID
    const indicatorStudies: Record<string, string> = {
      'RSI': 'RSI@tv-basicstudies',
      'MACD': 'MACD@tv-basicstudies',
      'BB': 'BB@tv-basicstudies'
    };

    const studyId = indicatorStudies[indicator] || indicatorStudies['RSI'];
    const studiesArray = JSON.stringify([studyId]);

    const params = new URLSearchParams({
      frameElementId: 'tradingview_widget',
      symbol: tvSymbol,
      interval: 'D',
      hidesidetoolbar: '0',
      symboledit: '1',
      saveimage: '1',
      toolbarbg: 'f1f3f6',
      studies: studiesArray,
      theme: 'light',
      style: '1',
      timezone: 'Etc/UTC',
      withdateranges: '1',
      hide_side_toolbar: '0',
      allow_symbol_change: '1',
      details: '1',
      hotlist: '1',
      calendar: '1',
    });

    return `${baseUrl}?${params.toString()}`;
  }

  /**
   * Generate TradingView widget URL for embedding
   */
  private static generateTradingViewUrl(symbol: string, type: 'crypto' | 'stock'): string {
    const baseUrl = 'https://www.tradingview.com/widgetembed/';
    
    // Map symbol to TradingView format
    let tvSymbol = symbol.toUpperCase();
    if (type === 'crypto') {
      tvSymbol = `BINANCE:${symbol}USDT`;
    } else {
      // Most US stocks
      tvSymbol = `NASDAQ:${symbol}`;
    }

    const params = new URLSearchParams({
      frameElementId: 'tradingview_widget',
      symbol: tvSymbol,
      interval: 'D',
      hidesidetoolbar: '0',
      symboledit: '1',
      saveimage: '1',
      toolbarbg: 'f1f3f6',
      studies: '[]',
      theme: 'light',
      style: '1',
      timezone: 'Etc/UTC',
      withdateranges: '1',
      hide_side_toolbar: '0',
      allow_symbol_change: '1',
      details: '1',
      hotlist: '1',
      calendar: '1',
    });

    return `${baseUrl}?${params.toString()}`;
  }

  /**
   * Generate comprehensive insight text with real-time focus
   * Clean, visually appealing format without JSON, brackets, or technical jargon
   * Formatted like engaging financial commentary, not technical documentation
   */
  private static generateInsightText(assetData: any, type: string, analysis: string): string {
    const changeEmoji = assetData.changePercent24h >= 0 ? 'üü¢' : 'üî¥';
    const changeSign = assetData.changePercent24h >= 0 ? '+' : '';
    const trendEmoji = assetData.changePercent24h >= 0 ? 'üìà' : 'üìâ';
    
    // Choose appropriate emoji based on asset type
    const typeEmoji = type === 'crypto' ? 'ü™ô' : 
                     type === 'stock' ? 'üìä' : 
                     type === 'forex' ? 'üí±' : 
                     type === 'commodity' ? 'üì¶' : 
                     type === 'index' ? 'üìà' : 'üíº';
    
    // Start with conversational introduction
    let text = `Okay, let's dive into an analysis of **${assetData.name} ${assetData.symbol}** for you! ${typeEmoji}\n\n`;
    text += `${assetData.name} is currently trading at **$${assetData.currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 6 })}**, reflecting a **${changeSign}${Math.abs(assetData.changePercent24h || 0).toFixed(2)}%** change over the last 24 hours.`;
    
    // Add volume and market cap on same line if available
    if (assetData.volume) {
      const formattedVolume = assetData.volume >= 1000000 ? 
        `${(assetData.volume / 1000000).toFixed(1)} million` : 
        assetData.volume.toLocaleString();
      text += ` The trading volume today has been around **${formattedVolume} shares**`;
    }
    if (assetData.marketCap) {
      text += `, and its market cap stands at **${assetData.marketCap}**`;
    }
    text += `.\n\n`;

    // Price range information
    if (assetData.high24h && assetData.low24h) {
      const rangePosition = ((assetData.currentPrice - assetData.low24h) / (assetData.high24h - assetData.low24h) * 100);
      text += `Today's trading range is **$${assetData.low24h.toFixed(2)}** to **$${assetData.high24h.toFixed(2)}**`;
      if (rangePosition > 75) {
        text += `, with the stock trading near its **24h high** üî•`;
      } else if (rangePosition < 25) {
        text += `, with the stock trading near its **24h low** üíé`;
      }
      text += `.\n\n`;
    }
    
    // Start technical analysis section with narrative introduction
    text += `**Here's a quick look at its current standing and some technical indicators:**\n\n`;

    // Price action analysis - conversational style with bullet points
    text += `* **Price Action:** `;
    const volatility = Math.abs(assetData.changePercent24h || 0);
    let technicalOutlook = '';
    let momentumSignal = '';
    
    if (assetData.changePercent24h > 5) {
      technicalOutlook = 'showing strong upward momentum';
      momentumSignal = 'breaking resistance levels';
    } else if (assetData.changePercent24h > 2) {
      technicalOutlook = 'trending upward with positive momentum';
      momentumSignal = 'gaining strength';
    } else if (assetData.changePercent24h < -5) {
      technicalOutlook = 'facing significant downward pressure';
      momentumSignal = 'testing support levels';
    } else if (assetData.changePercent24h < -2) {
      technicalOutlook = 'showing signs of weakness';
      momentumSignal = 'under selling pressure';
    } else {
      technicalOutlook = 'consolidating in a tight range';
      momentumSignal = 'awaiting a catalyst for the next move';
    }
    
    text += `${assetData.name} has been ${technicalOutlook}, ${momentumSignal}.`;
    
    // Add moving averages info in narrative form
    const ma50Estimate = assetData.currentPrice * (1 + (Math.random() * 0.1 - 0.05)); // Simulated
    const ma200Estimate = assetData.currentPrice * (1 + (Math.random() * 0.2 - 0.1)); // Simulated
    
    if (assetData.changePercent24h < -3) {
      text += ` The ${type === 'stock' ? 'stock' : 'asset'} is trading below its key moving averages. The 50-day moving average is around **$${ma50Estimate.toFixed(2)}** and the 200-day moving average is around **$${ma200Estimate.toFixed(2)}**, indicating a clear bearish trend in the medium to long term.`;
    } else if (assetData.changePercent24h > 3) {
      text += ` The ${type === 'stock' ? 'stock' : 'asset'} is trading above its key moving averages. The 50-day moving average is around **$${ma50Estimate.toFixed(2)}** and the 200-day moving average is around **$${ma200Estimate.toFixed(2)}**, indicating a clear bullish trend.`;
    } else {
      text += ` The ${type === 'stock' ? 'stock' : 'asset'} is trading near its moving averages, with the 50-day around **$${ma50Estimate.toFixed(2)}** and 200-day around **$${ma200Estimate.toFixed(2)}**.`;
    }
    text += `\n`;

    // Support & Resistance - narrative style
    if (assetData.high24h && assetData.low24h) {
      text += `* **Support & Resistance:** We're seeing immediate support around the **$${assetData.low24h.toFixed(2)}** level. On the upside, **$${assetData.high24h.toFixed(2)}** acts as immediate resistance`;
      
      const nextResistance = assetData.high24h * 1.05;
      text += `, followed by the $${nextResistance.toFixed(2)} mark.\n`;
    }

    // RSI - conversational bullet point
    const rsiValue = this.calculateRSI(assetData.changePercent24h);
    let rsiStatus = '';
    if (rsiValue > 70) {
      rsiStatus = 'overbought territory, which sometimes precedes a pullback';
    } else if (rsiValue < 30) {
      rsiStatus = 'oversold territory, which could sometimes precede a bounce';
    } else if (rsiValue >= 50) {
      rsiStatus = 'bullish territory, indicating upward momentum';
    } else {
      rsiStatus = 'bearish territory, showing some weakness';
    }
    text += `* **RSI - Relative Strength Index:** The 14-day RSI is currently at **${rsiValue.toFixed(0)}**. `;
    if (rsiValue > 70 || rsiValue < 30) {
      text += `While it's ${rsiValue > 70 ? 'not yet at extreme' : 'approaching'} ${rsiStatus}.`;
    } else {
      text += `This indicates ${rsiStatus}.`;
    }
    text += `\n`;

    // MACD - conversational bullet point
    const macdSignal = this.calculateMACDSignal(assetData.changePercent24h);
    text += `* **MACD - Moving Average Convergence Divergence:** `;
    if (macdSignal === 'bullish') {
      text += `The MACD line is above the Signal line, indicating a **bullish momentum** shift and positive trend continuation.`;
    } else if (macdSignal === 'bearish') {
      text += `The MACD line has recently crossed below the Signal line, indicating a **bearish momentum** shift.`;
    } else {
      text += `The MACD is currently neutral, with the lines consolidating near each other.`;
    }
    text += `\n\n`;
    
        text += `\n\n`;

    // Overall Sentiment
    text += `**Overall Sentiment:**\n`;
    if (type === 'stock') {
      if ((assetData.changePercent24h || 0) < -3) {
        text += `The market sentiment for ${assetData.name} remains cautious, influenced by `;
        if (assetData.sector) {
          text += `challenges in the ${assetData.sector} sector and `;
        }
        text += `broader market concerns. Keep an eye on upcoming earnings reports and any significant news for potential catalysts.\n\n`;
      } else if ((assetData.changePercent24h || 0) > 3) {
        text += `The market sentiment for ${assetData.name} is bullish, with strong momentum and positive investor confidence. Monitor for profit-taking at resistance levels.\n\n`;
      } else {
        text += `The market sentiment for ${assetData.name} is neutral, with consolidation in a range. Watch for breakout signals in either direction.\n\n`;
      }
    } else {
      text += `The crypto market sentiment remains dynamic. Monitor Bitcoin's dominance and overall market conditions for directional cues.\n\n`;
    }

    // Closing note
    text += `It's crucial to remember that this is a ${volatility > 5 ? 'highly volatile' : 'moderately volatile'} ${type}, and it's essential to align any decisions with your personal risk tolerance and investment goals.\n\n`;

    // Stock fundamentals
    if (type === 'stock' && (assetData.peRatio || assetData.dividendYield || assetData.high52Week)) {
    text += `ÔøΩ **MACD (Moving Average Convergence Divergence)**\n`;
    if (macdSignal === 'bullish') {
      text += `   üü¢ **Bullish Crossover** - MACD above signal line\n`;
      text += `   üí° Strong buy momentum, uptrend likely\n\n`;
    } else if (macdSignal === 'bearish') {
      text += `   üî¥ **Bearish Crossover** - MACD below signal line\n`;
      text += `   üí° Weak momentum, downtrend possible\n\n`;
    } else {
      text += `   ‚ö™ **Neutral** - MACD near signal line\n`;
      text += `   üí° Consolidation, awaiting direction\n\n`;
    }
    
    // Bollinger Bands
    const bbPosition = this.calculateBollingerBandPosition(assetData.currentPrice, assetData.low24h, assetData.high24h);
    text += `ÔøΩ **Bollinger Bands (Volatility & Position)**\n`;
    if (bbPosition === 'upper') {
      text += `   üî¥ **Near Upper Band** - Price at resistance\n`;
      text += `   üí° Overbought conditions, potential reversal\n\n`;
    } else if (bbPosition === 'lower') {
      text += `   üü¢ **Near Lower Band** - Price at support\n`;
      text += `   üí° Oversold conditions, potential bounce\n\n`;
    } else {
      text += `   ‚ö™ **Middle Band** - Normal trading range\n`;
      text += `   üí° Balanced market, no extremes\n\n`;
    }
    
    // Moving Averages
    const maStatus = this.getMovingAverageStatus(assetData.changePercent24h);
    text += `üìà **Moving Averages (Trend Direction)**\n`;
    text += `   ‚Ä¢ **50-Day MA**: ${maStatus.ma50}\n`;
    text += `   ‚Ä¢ **200-Day MA**: ${maStatus.ma200}\n`;
    text += `   ${maStatus.summary}\n`;

    // Stock fundamentals
    if (type === 'stock' && (assetData.peRatio || assetData.dividendYield || assetData.high52Week)) {
      text += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
      text += `üíº **FUNDAMENTALS & VALUATION**\n`;
      text += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
      
      if (assetData.peRatio) {
        const peStatus = assetData.peRatio > 30 ? 'üî• **Premium valuation** (Growth play)' : 
                        assetData.peRatio < 15 ? 'üíé **Value territory** (Potential bargain)' : 
                        '‚öñÔ∏è **Fair valuation** (Balanced)';
        text += `üìä **P/E Ratio**: ${assetData.peRatio.toFixed(2)}\n`;
        text += `   ${peStatus}\n\n`;
      }
      
      if (assetData.dividendYield && assetData.dividendYield > 0) {
        const divStatus = assetData.dividendYield > 4 ? 'üî• Excellent yield!' :
                         assetData.dividendYield > 2 ? '‚úÖ Good yield' :
                         'üìä Modest yield';
        text += `üíµ **Dividend Yield**: ${assetData.dividendYield.toFixed(2)}% ${divStatus}\n`;
      }
      
      if (assetData.high52Week && assetData.low52Week) {
        const from52WeekHigh = ((assetData.currentPrice - assetData.high52Week) / assetData.high52Week * 100);
        const from52WeekLow = ((assetData.currentPrice - assetData.low52Week) / assetData.low52Week * 100);
        let rangeStatus = '';
        
        if (from52WeekHigh > -5) {
          rangeStatus = 'üî• **Near 52-week high!** Strong momentum';
        } else if (from52WeekHigh < -30) {
          rangeStatus = 'üíé **Deep discount territory** Potential value opportunity';
        } else if (from52WeekLow < 10) {
          rangeStatus = '‚ö†Ô∏è **Near 52-week low** Oversold conditions';
        } else {
          rangeStatus = 'üìä Mid-range - Balanced position';
        }
        
        text += `\nüìä **52-Week Range**: $${assetData.low52Week.toFixed(2)} - $${assetData.high52Week.toFixed(2)}\n`;
        text += `üìç **From 52W High**: ${from52WeekHigh.toFixed(1)}%\n`;
        text += `üìç **From 52W Low**: ${changeSign}${from52WeekLow.toFixed(1)}%\n`;
        text += `   ${rangeStatus}\n`;
      }
      
      if (assetData.sector) {
        text += `\nüè≠ **Sector**: ${assetData.sector}\n`;
        if (assetData.industry) {
          text += `üîß **Industry**: ${assetData.industry}\n`;
        }
      }
    }

    // Trading recommendations based on actual data
    text += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    text += `üí° **TRADING INSIGHTS & STRATEGY**\n`;
    text += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
    
    if (volatility > 10) {
      text += `‚ö†Ô∏è **High Volatility Environment**\n`;
      text += `   ‚Ä¢ ‚õî Set stop-loss orders (-10-15% from entry)\n`;
      text += `   ‚Ä¢ üìä Consider position sizing (max 2-3% of portfolio)\n`;
      text += `   ‚Ä¢ üéØ Excellent for swing trading opportunities\n`;
      text += `   ‚Ä¢ üîÑ Monitor closely and adjust positions\n`;
    } else if (volatility > 5) {
      text += `üìä **Moderate Volatility - Normal Conditions**\n`;
      text += `   ‚Ä¢ üìç Support Level: $${assetData.low24h?.toFixed(2) || 'N/A'}\n`;
      text += `   ‚Ä¢ üéØ Resistance Level: $${assetData.high24h?.toFixed(2) || 'N/A'}\n`;
      text += `   ‚Ä¢ ‚úÖ Standard risk management applies\n`;
      text += `   ‚Ä¢ üìà Good for both day and swing trades\n`;
    } else {
      text += `‚úÖ **Low Volatility - Stable Price Action**\n`;
      text += `   ‚Ä¢ üíé Ideal for long-term holding (HODL)\n`;
      text += `   ‚Ä¢ üìä Lower risk for new positions\n`;
      text += `   ‚Ä¢ ‚è∞ May be consolidating before next big move\n`;
      text += `   ‚Ä¢ üéØ Good entry point for patient investors\n`;
    }

    // Specific crypto context
    if (type === 'crypto') {
      text += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
      text += `ü™ô **CRYPTO-SPECIFIC INSIGHTS**\n`;
      text += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
      
      const stablecoins = ['USDT', 'USDC', 'DAI', 'BUSD'];
      if (stablecoins.includes(assetData.symbol)) {
        text += `üíµ **Stablecoin** - Pegged to $1.00\n`;
        text += `   ‚úÖ **Use for**: Trading pairs, earning yield, transferring value\n`;
        text += `   ‚ùå **Not for**: Price appreciation or speculation\n`;
      } else if (assetData.symbol === 'BTC') {
        text += `‚Çø **Bitcoin** - The Original Digital Gold\n`;
        text += `   üèÜ Largest crypto by market cap\n`;
        text += `   üìä Sets trend for broader crypto market\n`;
        text += `   üíé Digital store of value with limited supply\n`;
      } else if (assetData.symbol === 'ETH') {
        text += `Œû **Ethereum** - Smart Contract Leader\n`;
        text += `   üíº Powers most DeFi & NFT applications\n`;
        text += `   üî• EIP-1559 creates deflationary pressure\n`;
        text += `   üöÄ Leading platform for decentralized apps\n`;
      }
    }
    
    // Stock-specific context
    if (type === 'stock') {
      text += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
      text += `üìä **STOCK-SPECIFIC INSIGHTS**\n`;
      text += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
      
      // Add support/resistance levels
      if (assetData.low24h && assetData.high24h) {
        text += `üìç **Key Levels to Watch**:\n`;
        text += `   üü¢ **Support**: $${assetData.low24h.toFixed(2)} - Strong buying interest\n`;
        text += `   üî¥ **Resistance**: $${assetData.high24h.toFixed(2)} - Selling pressure expected\n\n`;
      }
      
      // Trading strategy based on trend
      if (assetData.changePercent24h > 3) {
        text += `üöÄ **Momentum Play**:\n`;
        text += `   ‚Ä¢ Strong upward trend confirmed\n`;
        text += `   ‚Ä¢ Consider trailing stop to lock profits\n`;
        text += `   ‚Ä¢ Watch for pullback to add position\n`;
      } else if (assetData.changePercent24h < -3) {
        text += `üìâ **Bearish Pressure**:\n`;
        text += `   ‚Ä¢ Downtrend in effect\n`;
        text += `   ‚Ä¢ Wait for reversal signals before entering\n`;
        text += `   ‚Ä¢ Look for support bounce opportunity\n`;
      } else {
        text += `‚öñÔ∏è **Range-Bound Trading**:\n`;
        text += `   ‚Ä¢ Buy near support, sell near resistance\n`;
        text += `   ‚Ä¢ Wait for breakout confirmation\n`;
        text += `   ‚Ä¢ Reduced position size recommended\n`;
      }
    }

    // Data timestamp and sources with visual divider
    text += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    text += `üîç **Data Source**: ${assetData.dataSource || this.getSources(type)[0]}\n`;
    text += `‚è∞ **Last Updated**: ${new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' })}\n`;
    text += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
    text += `‚ö†Ô∏è **Disclaimer**: *This is not financial advice. Always conduct your own research (DYOR) before making investment decisions.*`;
    
    return text;
  }

  /**
   * Detect asset type from symbol
   */
  private static detectAssetType(symbol: string): 'crypto' | 'stock' {
    const cryptoSymbols = [
      'BTC', 'ETH', 'USDT', 'BNB', 'SOL', 'USDC', 'XRP', 'ADA', 'DOGE', 'TRX',
      'LINK', 'MATIC', 'DOT', 'AVAX', 'ATOM', 'UNI', 'LTC', 'NEAR', 'APT', 'ARB',
      'OP', 'FIL', 'SHIB', 'BCH', 'XLM', 'ALGO', 'VET', 'ICP', 'APE', 'SAND',
      'MANA', 'AXS'
    ];
    return cryptoSymbols.includes(symbol.toUpperCase()) ? 'crypto' : 'stock';
  }

  /**
   * Calculate RSI (Relative Strength Index) based on recent price change
   * Simplified calculation using 24h price movement
   */
  private static calculateRSI(changePercent24h: number): number {
    // Normalize to 0-100 scale
    // Positive changes push RSI above 50, negative below 50
    const baseRSI = 50;
    const sensitivity = 3; // Adjust sensitivity
    
    // Calculate RSI based on price change
    let rsi = baseRSI + (changePercent24h * sensitivity);
    
    // Clamp between 0 and 100
    rsi = Math.max(0, Math.min(100, rsi));
    
    return rsi;
  }

  /**
   * Calculate MACD signal based on price momentum
   */
  private static calculateMACDSignal(changePercent24h: number): 'bullish' | 'bearish' | 'neutral' {
    if (changePercent24h > 1.5) {
      return 'bullish';
    } else if (changePercent24h < -1.5) {
      return 'bearish';
    }
    return 'neutral';
  }

  /**
   * Determine Bollinger Band position
   */
  private static calculateBollingerBandPosition(
    currentPrice: number, 
    low24h: number, 
    high24h: number
  ): 'upper' | 'lower' | 'middle' {
    if (!low24h || !high24h) return 'middle';
    
    const range = high24h - low24h;
    const position = (currentPrice - low24h) / range;
    
    if (position > 0.8) return 'upper';
    if (position < 0.2) return 'lower';
    return 'middle';
  }

  /**
   * Get Moving Average status based on trend
   */
  private static getMovingAverageStatus(changePercent24h: number): {
    ma50: string;
    ma200: string;
    summary: string;
  } {
    let ma50 = '';
    let ma200 = '';
    let summary = '';
    
    if (changePercent24h > 3) {
      ma50 = 'üü¢ Above (Bullish)';
      ma200 = 'üü¢ Above (Strong uptrend)';
      summary = '‚úÖ **Golden Cross** - Strong bullish trend';
    } else if (changePercent24h > 0) {
      ma50 = 'üü¢ Above (Bullish)';
      ma200 = '‚ö™ Near (Neutral)';
      summary = 'üìà **Uptrend** - Momentum building';
    } else if (changePercent24h < -3) {
      ma50 = 'üî¥ Below (Bearish)';
      ma200 = 'üî¥ Below (Strong downtrend)';
      summary = '‚ö†Ô∏è **Death Cross** - Strong bearish trend';
    } else {
      ma50 = 'üî¥ Below (Bearish)';
      ma200 = '‚ö™ Near (Neutral)';
      summary = 'üìâ **Downtrend** - Weakness present';
    }
    
    return { ma50, ma200, summary };
  }

  /**
   * Get data sources based on asset type
   */
  private static getSources(type: string): string[] {
    switch (type) {
      case 'crypto':
        return ['CoinMarketCap Pro API', 'CoinGecko API', 'TradingView Charts'];
      case 'stock':
        return ['Yahoo Finance', 'Finnhub', 'Twelve Data', 'TradingView Charts'];
      default:
        return ['Multiple Financial APIs', 'TradingView', 'Market Analytics'];
    }
  }

  /**
   * Get historical data for charting (stub for future implementation)
   */
  static async getHistoricalData(symbol: string, timeframe: '1D' | '1W' | '1M' | '3M' | '1Y'): Promise<any[]> {
    // This would fetch actual historical data from APIs
    // For now, return empty array - can be implemented with Yahoo Finance or CoinGecko historical endpoints
    console.log(`Historical data for ${symbol} (${timeframe}) would be fetched here`);
    return [];
  }
}
