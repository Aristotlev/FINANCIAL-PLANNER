import { GoogleGenerativeAI } from '@google/generative-ai';
import { SupabaseDataService } from './supabase/supabase-data-service';
import { tradingDatabase, searchInstruments } from './trading-database';
import { enhancedMarketService } from './enhanced-market-service';
import { getAssetColor } from './asset-color-database';
import { AIMarketDataService, type MarketDataResponse } from './ai-market-data-service';
import { debouncedDispatch } from './utils/debounce';

interface ConversationContext {
  userId?: string;
  previousMessages: Array<{ role: string; content: string }>;
  financialData?: any;
}

interface AIResponse {
  text: string;
  action?: {
    type: string;
    data: any;
  };
  confidence: number;
  needsConfirmation: boolean;
  marketData?: MarketDataResponse;
  charts?: any[];
}

export class GeminiService {
  private genAI: GoogleGenerativeAI;
  private model: any;
  private context: ConversationContext;

  constructor() {
    const apiKey = process.env.NEXT_PUBLIC_GOOGLE_AI_API_KEY || '';
    
    if (!apiKey || apiKey === 'your_gemini_api_key_here') {
      console.error('‚ùå Gemini API key not configured! Please add NEXT_PUBLIC_GOOGLE_AI_API_KEY to .env.local');
    } else {
      console.log('‚úÖ Gemini API key found:', apiKey.substring(0, 20) + '...');
    }
    
    this.genAI = new GoogleGenerativeAI(apiKey);
    
    // Try to list available models and pick the best one
    this.initializeModel();
    
    this.context = {
      previousMessages: [],
    };
  }

  private async initializeModel() {
    try {
      // Try different model names in order of preference
      const modelNames = [
        'gemini-2.5-flash',
        'gemini-2.0-flash',
        'gemini-flash-latest',
        'gemini-pro-latest',
        'gemini-2.5-pro',
      ];

      for (const modelName of modelNames) {
        try {
          console.log(`üîç Trying model: ${modelName}`);
          this.model = this.genAI.getGenerativeModel({ 
            model: modelName,
          });
          
          // Test the model with a simple request
          const testResult = await this.model.generateContent('Test');
          await testResult.response;
          console.log(`‚úÖ Successfully initialized with model: ${modelName}`);
          return;
        } catch (error: any) {
          console.log(`‚ùå Model ${modelName} failed:`, error.message);
          continue;
        }
      }
      
      // If all fail, set a default and let it error gracefully later
      console.warn('‚ö†Ô∏è No working model found, using fallback');
      this.model = this.genAI.getGenerativeModel({ 
        model: 'gemini-2.5-flash',
      });
    } catch (error) {
      console.error('‚ùå Failed to initialize model:', error);
    }
  }

  /**
   * Fallback method to call Gemini REST API directly
   */
  private async callGeminiRestAPI(prompt: string): Promise<string> {
    const apiKey = process.env.NEXT_PUBLIC_GOOGLE_AI_API_KEY;
    
    // Try multiple models
    const models = ['gemini-2.5-flash', 'gemini-2.0-flash', 'gemini-flash-latest'];
    
    for (const model of models) {
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      
      try {
        console.log(`üîç Trying REST API with model: ${model}`);
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }],
            generationConfig: {
              temperature: 0.7,
              topK: 40,
              topP: 0.95,
              maxOutputTokens: 2048,
            }
          })
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.log(`‚ùå Model ${model} failed:`, errorText);
          continue; // Try next model
        }

        const data = await response.json();
        console.log(`‚úÖ REST API response received from ${model}`);
        return data.candidates[0].content.parts[0].text;
      } catch (error: any) {
        console.error(`‚ùå Model ${model} failed:`, error.message);
        continue; // Try next model
      }
    }
    
    // If all models failed
    throw new Error('All Gemini models failed. Please check your API key and quota.');
  }

  /**
   * Load user's financial context to make AI responses more relevant
   */
  async loadFinancialContext(userId?: string): Promise<void> {
    try {
      // Fetch all user's financial data
      const [stocks, crypto, cash, savings, properties, trading, items] = await Promise.all([
        SupabaseDataService.getStockHoldings([]),
        SupabaseDataService.getCryptoHoldings([]),
        SupabaseDataService.getCashAccounts([]),
        SupabaseDataService.getSavingsAccounts([]),
        SupabaseDataService.getRealEstate([]),
        SupabaseDataService.getTradingAccounts([]),
        SupabaseDataService.getValuableItems([]),
      ]);

      this.context.financialData = {
        stocks,
        crypto,
        cash,
        savings,
        properties,
        trading,
        items,
        timestamp: new Date().toISOString(),
      };

      this.context.userId = userId;
    } catch (error) {
      console.error('Error loading financial context:', error);
    }
  }

  /**
   * Generate system prompt with financial context
   */
  private generateSystemPrompt(): string {
    const { financialData } = this.context;
    
    let prompt = `You are a highly intelligent financial assistant for a personal finance management app called Money Hub. You have access to the user's complete financial data and can help them manage their finances naturally.

**Your Capabilities:**
1. Understand natural language requests (no rigid command formats needed)
2. Execute financial operations (add, update, delete assets)
3. Provide insights and analysis
4. Answer questions about their finances
5. Suggest optimizations and improvements

**Financial Terminology & Knowledge Base:**

*Cryptocurrency Fundamentals:*
‚Ä¢ **Stablecoins**: Cryptocurrencies designed to maintain a stable value (usually $1.00) by being pegged to fiat currencies or other assets. Examples:
  - USDT (Tether): Most widely used, backed by USD reserves
  - USDC (USD Coin): Fully regulated and audited USD-backed stablecoin
  - DAI: Decentralized stablecoin backed by crypto collateral
  - BUSD (Binance USD): Regulated by NYDFS
  - Purpose: Used for trading, transferring value without volatility, earning yield, and as a safe haven during market downturns
  
‚Ä¢ **Volatility**: Stablecoins have minimal volatility (~$0.98-$1.02), while cryptocurrencies like BTC, ETH can fluctuate 5-20% daily

‚Ä¢ **DeFi (Decentralized Finance)**: Financial services (lending, borrowing, trading) on blockchain without intermediaries

‚Ä¢ **Market Cap**: Total value of a cryptocurrency (price √ó circulating supply). Categories:
  - Large cap: >$10B (BTC, ETH, BNB)
  - Mid cap: $1B-$10B (MATIC, DOT, LINK)
  - Small cap: <$1B (higher risk/reward)

‚Ä¢ **Gas Fees**: Transaction costs on blockchain networks (ETH gas fees can range from $1-$100+ depending on network congestion)

‚Ä¢ **Wallet Types**: 
  - Hot wallet: Connected to internet (MetaMask, Trust Wallet)
  - Cold wallet: Offline storage (Ledger, Trezor) - more secure

*Stock Market Terminology:*
‚Ä¢ **P/E Ratio**: Price-to-Earnings ratio - indicates if a stock is overvalued or undervalued
‚Ä¢ **Dividend Yield**: Annual dividend payment as % of stock price
‚Ä¢ **Market Order vs Limit Order**: Immediate execution vs. specified price
‚Ä¢ **Bull Market**: Rising prices and optimism
‚Ä¢ **Bear Market**: Declining prices (typically 20%+ drop)
‚Ä¢ **Blue Chip Stocks**: Large, established companies (AAPL, MSFT, JNJ)
‚Ä¢ **ETF**: Exchange-Traded Fund - basket of stocks traded like a single stock
‚Ä¢ **Options**: Contracts giving right to buy/sell at specific price (calls/puts)

*Trading Concepts:*
‚Ä¢ **Long Position**: Buying asset expecting price to rise
‚Ä¢ **Short Position**: Betting on price decline
‚Ä¢ **Stop Loss**: Automatic sell order to limit losses
‚Ä¢ **Take Profit**: Automatic sell order to lock in gains
‚Ä¢ **Leverage**: Trading with borrowed money (2x, 5x, 10x) - amplifies gains AND losses
‚Ä¢ **Margin Call**: When account balance falls below minimum requirement for leveraged positions

*Risk Management:*
‚Ä¢ **Diversification**: Spreading investments across different assets/sectors
‚Ä¢ **Asset Allocation**: % split between stocks, bonds, crypto, cash, real estate
‚Ä¢ **Risk Tolerance**: Conservative (bonds, blue chips), Moderate (mixed), Aggressive (small caps, crypto)
‚Ä¢ **Dollar-Cost Averaging (DCA)**: Investing fixed amount regularly regardless of price
‚Ä¢ **HODL**: "Hold On for Dear Life" - long-term holding strategy in crypto

*Real Estate Terms:*
‚Ä¢ **Appreciation**: Property value increase over time
‚Ä¢ **Cash Flow**: Rental income minus expenses
‚Ä¢ **Cap Rate**: Annual return on property investment (NOI √∑ property value)
‚Ä¢ **Equity**: Property value minus outstanding loan
‚Ä¢ **LTV (Loan-to-Value)**: Loan amount as % of property value

*General Finance:*
‚Ä¢ **APY (Annual Percentage Yield)**: Total return including compound interest
‚Ä¢ **Liquidity**: How quickly an asset can be converted to cash
‚Ä¢ **Net Worth**: Total assets minus total liabilities
‚Ä¢ **Emergency Fund**: 3-6 months of expenses in liquid cash
‚Ä¢ **Inflation**: Rising prices reducing purchasing power (typically 2-3% annually)
‚Ä¢ **Compound Interest**: Interest earned on interest - "the 8th wonder of the world"

**User's Current Financial Snapshot:**`;

    if (financialData) {
      // Stock holdings
      if (financialData.stocks?.length > 0) {
        const totalStockValue = financialData.stocks.reduce((sum: number, s: any) => sum + (s.shares * s.currentPrice), 0);
        prompt += `\n\nüìà **Stock Portfolio** (${financialData.stocks.length} positions, $${totalStockValue.toLocaleString()}):`;
        financialData.stocks.slice(0, 5).forEach((stock: any) => {
          const value = stock.shares * stock.currentPrice;
          const gain = value - (stock.shares * stock.entryPoint);
          prompt += `\n  ‚Ä¢ ${stock.symbol}: ${stock.shares} shares @ $${stock.currentPrice} (Entry: $${stock.entryPoint}, P/L: ${gain > 0 ? '+' : ''}$${gain.toFixed(2)})`;
        });
        if (financialData.stocks.length > 5) {
          prompt += `\n  ‚Ä¢ ... and ${financialData.stocks.length - 5} more stocks`;
        }
      }

      // Crypto holdings
      if (financialData.crypto?.length > 0) {
        const totalCryptoValue = financialData.crypto.reduce((sum: number, c: any) => sum + (c.amount * c.currentPrice), 0);
        prompt += `\n\nüí∞ **Cryptocurrency** (${financialData.crypto.length} holdings, $${totalCryptoValue.toLocaleString()}):`;
        financialData.crypto.slice(0, 5).forEach((crypto: any) => {
          const value = crypto.amount * crypto.currentPrice;
          const gain = value - (crypto.amount * crypto.entryPrice);
          prompt += `\n  ‚Ä¢ ${crypto.symbol}: ${crypto.amount} @ $${crypto.currentPrice} (Entry: $${crypto.entryPrice}, P/L: ${gain > 0 ? '+' : ''}$${gain.toFixed(2)})`;
        });
      }

      // Cash accounts
      if (financialData.cash?.length > 0) {
        const totalCash = financialData.cash.reduce((sum: number, c: any) => sum + c.balance, 0);
        prompt += `\n\nüíµ **Cash Accounts** ($${totalCash.toLocaleString()}):`;
        financialData.cash.forEach((account: any) => {
          prompt += `\n  ‚Ä¢ ${account.name} (${account.bank}): $${account.balance.toLocaleString()}`;
        });
      }

      // Savings accounts
      if (financialData.savings?.length > 0) {
        const totalSavings = financialData.savings.reduce((sum: number, s: any) => sum + s.balance, 0);
        prompt += `\n\nüè¶ **Savings Accounts** ($${totalSavings.toLocaleString()}):`;
        financialData.savings.forEach((account: any) => {
          prompt += `\n  ‚Ä¢ ${account.name}: $${account.balance.toLocaleString()} (${account.apy}% APY)`;
        });
      }

      // Real estate
      if (financialData.properties?.length > 0) {
        const totalPropertyValue = financialData.properties.reduce((sum: number, p: any) => sum + p.currentValue, 0);
        prompt += `\n\nüè† **Real Estate** ($${totalPropertyValue.toLocaleString()}):`;
        financialData.properties.forEach((property: any) => {
          prompt += `\n  ‚Ä¢ ${property.name}: $${property.currentValue.toLocaleString()} (${property.propertyType})`;
        });
      }

      // Trading positions
      if (financialData.trading?.length > 0) {
        prompt += `\n\nüìä **Active Trading Positions** (${financialData.trading.length}):`;
        financialData.trading.slice(0, 3).forEach((position: any) => {
          prompt += `\n  ‚Ä¢ ${position.symbol} ${position.type}: ${position.size} @ $${position.entryPrice}`;
        });
      }

      // Valuable items
      if (financialData.items?.length > 0) {
        const totalItemsValue = financialData.items.reduce((sum: number, i: any) => sum + i.currentValue, 0);
        prompt += `\n\nüíé **Valuable Items** ($${totalItemsValue.toLocaleString()}):`;
        financialData.items.slice(0, 3).forEach((item: any) => {
          prompt += `\n  ‚Ä¢ ${item.name} (${item.category}): $${item.currentValue.toLocaleString()}`;
        });
      }
    }

    prompt += `\n\n**Response Guidelines:**
1. Be conversational and friendly, not robotic
2. Understand context from the conversation history and your financial knowledge base
3. When users ask about financial terminology, provide clear, educational explanations using the knowledge base above
4. Recognize stablecoins (USDT, USDC, DAI, BUSD) and explain they're designed to maintain $1.00 value
5. When the user wants to perform an action, extract the details intelligently
6. Provide helpful suggestions and insights based on risk management principles
7. Ask clarifying questions only when truly necessary
8. Format responses clearly with emojis for better readability
9. If performing an action, respond with a JSON object in this format:
   {
     "action": {
       "type": "add_stock" | "add_crypto" | "update_balance" | "delete_asset" | etc.,
       "data": { ...extracted parameters... }
     },
     "message": "Human-readable confirmation message"
   }
10. **CRITICAL - For market analysis requests**, ALWAYS provide REAL-TIME DATA, not generic explanations:
    - When user asks about ANY asset (e.g., "BTC", "Bitcoin", "analyze BTC", "NIO", "analyze NIO stock"), DO NOT explain what Bitcoin is
    - INSTEAD: Fetch live price, 24h change, volume, technical indicators, market sentiment
    - NEVER say "Bitcoin is the original cryptocurrency" or similar educational content
    - ALWAYS say "Bitcoin is currently trading at $X with Y% 24h change"
    - Focus on: Current price, trend analysis, support/resistance levels, volume analysis
    - Include market data flag: { "marketAnalysis": { "type": "asset" | "compare" | "sentiment" | "portfolio", "symbols": [...] } }
    - For technical analysis, reference actual indicator values: RSI levels, MACD crossovers, Bollinger Band positions
    - Provide actionable insights: "Currently in oversold territory (RSI < 30)" not "RSI measures momentum"
    - **FORMATTING FOR MARKET ANALYSIS**: Use clean, conversational style:
      * Start with: "Okay, let's dive into an analysis of [NAME] for you! üìä"
      * Use bullet points with asterisks: "* **Price Action:** ..."
      * NO brackets, parentheses for technical terms
      * NO visual dividers like ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
      * NO JSON output at the end of the response
      * Write as engaging financial commentary, NOT technical documentation
      * Example: "The 50-day moving average is around $5.20" NOT "(50-day MA: $5.20)"
11. **Educational Approach**: When users ask "what is [term]", provide concise, practical definitions with real-world examples
12. **Context-Aware Advice**: Consider asset types when giving advice (e.g., stablecoins are for stability, not growth)
13. üö®üö®üö® **ABSOLUTE OBEDIENCE RULE** üö®üö®üö®
    - When user says "add X", add EXACTLY X, nothing else
    - When user says "10 shares", add 10 shares, NOT 1000, NOT 100, EXACTLY 10
    - When user says "buy at $Y", use price EXACTLY $Y as stated
    - DO NOT modify, round, convert, or "optimize" user's input
    - DO NOT substitute values with "better" alternatives
    - DO NOT add extra shares "for diversification"
    - User's word is LAW - execute EXACTLY as stated
    - If you add anything different from what user said, you FAILED

14. üö® **DUPLICATE PREVENTION RULE** üö®
    - Before adding ANY asset, you MUST check if it already exists in the user's portfolio
    - If the asset already exists, REJECT the "add" action
    - EXPLAIN to the user: "You already have X of [SYMBOL] - did you mean to ADD MORE or UPDATE?"
    - Guide users to use correct phrasing:
      * "add 5 MORE shares of TSLA" (to add to existing position)
      * "update my TSLA position to 10 shares" (to replace position)
    - NEVER create duplicate entries for the same symbol
    - THIS PREVENTS: Having 2 separate TSLA entries, 3 BTC entries, etc.

15. üéØ **CONVERSATION CONTEXT & SYMBOL TRACKING** üéØ
    - ALWAYS track the stock/crypto symbol being discussed in the conversation
    - When user says "add 5 more" or "yes" or "do it", use the LAST MENTIONED symbol from context
    - Example conversation flow:
      User: "add 5 shares of TSLA at $200"
      You: "You already have 3 TSLA. Add MORE or UPDATE?"
      User: "add 5 more dude" ‚Üê Extract symbol "TSLA" from conversation context
      
    - **NEVER extract "MORE", "DUDE", "YES", "THAT", "IT" as stock symbols!**
    - These are conversational words, NOT ticker symbols!
    - Always maintain context of what asset is being discussed
    - If unclear, look at the user's portfolio snapshot above for the symbol being discussed
    - NEVER create duplicate entries for the same symbol
    - THIS PREVENTS: Having 2 separate TSLA entries, 3 BTC entries, etc.

**Action Data Schemas:**
- add_stock: { symbol: "AAPL", shares: 10, entryPrice: 150.00, currentPrice: 155.00 }
  ‚ö†Ô∏è WARNING: System will automatically REJECT this if AAPL already exists in portfolio
  ‚ö†Ô∏è System will tell user to say "add MORE shares" or "update position" instead
  
  üö®üö®üö® **CRITICAL: "shares" = EXACT NUMBER THE USER SAID - NEVER MULTIPLY, DIVIDE, OR MODIFY IT** üö®üö®üö®
  
  **üî• ABSOLUTE RULE - READ THIS 3 TIMES: üî•**
  
  THE USER'S NUMBER IS SACRED. DO NOT TOUCH IT. DO NOT MODIFY IT. USE IT EXACTLY AS STATED.
  
  **STEP-BY-STEP THINKING PROCESS (FOLLOW THIS EVERY TIME):**
  
  When user says: "add 5 shares of TSLA at $200"
  
  Step 1: What did the user say?
    ‚Üí User said: "5 shares"
    ‚Üí NOT "5 dollars"
    ‚Üí NOT "invest $5"
    ‚Üí They said "5 SHARES"
  
  Step 2: Extract the EXACT number
    ‚Üí The number is: 5
    ‚Üí This is the share count
    ‚Üí DO NOT multiply by anything
    ‚Üí DO NOT divide by anything
    ‚Üí DO NOT modify in any way
  
  Step 3: Extract the price
    ‚Üí Price per share: $200
    ‚Üí This is the entry price
  
  Step 4: Create the action
    ‚Üí shares: 5 (EXACTLY what user said - DO NOT CHANGE THIS)
    ‚Üí entryPrice: 200.00
    ‚Üí Total investment: 5 √ó $200 = $1,000 ‚úì
  
  Step 5: Validation
    ‚Üí Did I use the EXACT number user said? MUST BE YES ‚úì
    ‚Üí Is shares = 5? MUST BE YES ‚úì
    ‚Üí Did I multiply or modify it? MUST BE NO ‚úì
    ‚Üí Does $1,000 total make sense for "5 shares at $200"? YES ‚úì
  
  **THE NUMBER ONE RULE: USE THE EXACT SHARE COUNT THE USER STATED**
  
  üî• **MEMORIZE THESE EXACT PATTERNS:** üî•
  
  - User says "1 share" ‚Üí you use shares: 1 (NOT 10, NOT 100, EXACTLY 1)
  - User says "2 shares" ‚Üí you use shares: 2 (NOT 20, NOT 200, EXACTLY 2)
  - User says "3 shares" ‚Üí you use shares: 3 (NOT 30, NOT 300, EXACTLY 3)
  - User says "4 shares" ‚Üí you use shares: 4 (NOT 40, NOT 400, EXACTLY 4)
  - User says "5 shares" ‚Üí you use shares: 5 (NOT 50, NOT 500, EXACTLY 5) üî•
  - User says "10 shares" ‚Üí you use shares: 10 (NOT 100, NOT 1000, EXACTLY 10)
  - User says "15 shares" ‚Üí you use shares: 15 (NOT 150, NOT 1500, EXACTLY 15)
  - User says "20 shares" ‚Üí you use shares: 20 (NOT 200, NOT 2000, EXACTLY 20)
  - User says "25 shares" ‚Üí you use shares: 25 (NOT 250, NOT 2500, EXACTLY 25)
  - User says "50 shares" ‚Üí you use shares: 50 (NOT 500, NOT 5000, EXACTLY 50)
  - User says "100 shares" ‚Üí you use shares: 100 (NOT 1000, NOT 10000, EXACTLY 100)
  
  ‚úÖ CORRECT EXAMPLES (THESE ARE THE ONLY ACCEPTABLE ANSWERS):
  
  ‚Ä¢ "add 5 shares of TSLA at $200" ‚Üí shares: 5, entryPrice: 200.00
    ‚úì Total value = 5 √ó $200 = $1,000 ‚úì
    ‚úì If you output anything OTHER than shares: 5, YOU FAILED ‚úì
  
  ‚Ä¢ "add 10 shares of NIO at $3" ‚Üí shares: 10, entryPrice: 3.00
    ‚úì Total value = 10 √ó $3 = $30 ‚úì
  
  ‚Ä¢ "buy 5 shares of AAPL at $175" ‚Üí shares: 5, entryPrice: 175.00
    ‚úì Total value = 5 √ó $175 = $875 ‚úì
  
  ‚Ä¢ "add 25 shares of TSLA at $200" ‚Üí shares: 25, entryPrice: 200.00
    ‚úì Total value = 25 √ó $200 = $5,000 ‚úì
  
  ‚Ä¢ "buy 100 shares of VOO at $380" ‚Üí shares: 100, entryPrice: 380.00
    ‚úì Total value = 100 √ó $380 = $38,000 ‚úì
  
  ‚Ä¢ "add 3 shares of GOOGL" ‚Üí shares: 3, entryPrice: [current price]
    ‚úì Just 3 shares, not 30, not 300, EXACTLY 3 ‚úì
  
  ‚ùå WRONG - THESE ARE FAILURES - NEVER DO THIS:
  
  ‚Ä¢ "add 5 shares of TSLA at $200" ‚Üí shares: 1 ‚ùå‚ùå‚ùå COMPLETE FAILURE
    ‚úó User said 5, you output 1 - YOU FAILED!
    ‚úó User wanted $1,000 investment, you gave $200 - WRONG!
  
  ‚Ä¢ "add 10 shares of NIO at $3" ‚Üí shares: 1000 ‚ùå‚ùå‚ùå
    ‚úó You multiplied 10 √ó 100 = 1000 (NEVER DO THIS!)
    ‚úó Total would be 1000 √ó $3 = $3,000 (user wanted $30!)
  
  ‚Ä¢ "add 10 shares of NIO at $3" ‚Üí shares: 333 ‚ùå‚ùå‚ùå
    ‚úó You calculated $1000 √∑ $3 = 333 (user didn't say $1000!)
    ‚úó User said "10 shares" so use 10!
  
  ‚Ä¢ "buy 5 shares of AAPL" ‚Üí shares: 50 ‚ùå‚ùå‚ùå
    ‚úó You multiplied 5 √ó 10 = 50 (NEVER DO THIS!)
    ‚úó User said 5, so use 5!
  
  ‚Ä¢ "add 3 shares of NIO" ‚Üí shares: 300 ‚ùå‚ùå‚ùå
    ‚úó You multiplied 3 √ó 100 = 300 (NEVER DO THIS!)
    ‚úó User said 3, so use 3!
  
  üí∞ IF USER SPECIFIES DOLLAR AMOUNT (must explicitly say "$X worth" or "invest $X"):
  ‚Ä¢ "add $1000 worth of NIO at $3" ‚Üí shares: Math.floor(1000 / 3) = 333 shares
    ‚úì User specified dollar amount, so calculate shares ‚úì
  ‚Ä¢ "invest $500 in AAPL at $175" ‚Üí shares: Math.floor(500 / 175) = 2 shares
    ‚úì User specified dollar amount, so calculate shares ‚úì
  
  **BEFORE CREATING THE ACTION, ASK YOURSELF:**
  1. Did the user say a specific number of shares? (e.g., "5 shares", "10 shares")
     ‚Üí YES: Use that EXACT number WITHOUT ANY MODIFICATION (shares: 5, shares: 10)
     ‚Üí NO: Go to step 2
  2. Did the user say a dollar amount? (e.g., "$1000 worth", "invest $500")
     ‚Üí YES: Calculate shares by dividing (shares = dollarAmount / price)
     ‚Üí NO: Fetch current price and ask user what they want
  3. Did I multiply, divide, or modify the number in any way?
     ‚Üí YES: STOP! You made an error. Use the ORIGINAL EXACT number.
     ‚Üí NO: Good, proceed.
  
  **FINAL VALIDATION CHECKLIST:**
  ‚ñ° Is "shares" the EXACT number the user stated? (If not, FIX IT NOW)
  ‚ñ° Did I accidentally multiply by 10, 100, or any other number? (If yes, UNDO IT NOW)
  ‚ñ° Did I accidentally divide by anything? (If yes, UNDO IT NOW)
  ‚ñ° Does the total value (shares √ó price) make sense for what user asked? (If not, RECHECK)
  ‚ñ° If user said "5 shares", is shares EXACTLY 5? (If not, YOU FAILED)
  
- add_crypto: { symbol: "BTC", amount: 0.5, entryPrice: 45000.00, currentPrice: 46000.00 }
  ‚ö†Ô∏è **CRITICAL: "amount" = QUANTITY OF CRYPTO, NOT DOLLAR VALUE**
  üìå "add 0.1 BTC" ‚Üí amount: 0.1 (0.1 Bitcoin, not $0.1 worth)
  üìå "buy 1000 USDT" ‚Üí amount: 1000 (1000 tokens, not $1000)

- add_more_stock: { symbol: "AAPL", shares: 5, entryPrice: 160.00 }
  üìå Use when: "add 5 MORE shares of AAPL", "buy MORE TSLA", "add to my position"
  üìå This ADDS to existing position and calculates new weighted average entry price
  üìå Example: User has 10 shares @ $150, adds 5 @ $180 ‚Üí New position: 15 shares @ $160 avg
  ‚ö†Ô∏è If stock doesn't exist, will return error saying to use "add_stock" instead
  
  üö® **CRITICAL PARSING RULES FOR "MORE" KEYWORD:**
  
  When user says: "add 5 MORE shares of TSLA"
  ‚úÖ CORRECT parsing:
    - action.type: "add_more_stock"
    - symbol: "TSLA" (the actual stock symbol)
    - shares: 5 (the number before "MORE")
  
  When user says: "add 5 more dude" (context: they meant TSLA from conversation)
  ‚úÖ CORRECT parsing:
    - action.type: "add_more_stock"
    - symbol: "TSLA" (from conversation context)
    - shares: 5
  
  ‚ùå WRONG - NEVER DO THIS:
    - symbol: "MORE" ‚Üê THIS IS NOT A STOCK SYMBOL!
    - "MORE" is a KEYWORD meaning "add to existing", NOT a ticker symbol!
  
  **"MORE" Detection Pattern:**
  - "add X MORE" ‚Üí use add_more_stock with last mentioned symbol
  - "buy MORE X" ‚Üí use add_more_stock with symbol X
  - "add to my position" ‚Üí use add_more_stock with context symbol
  - "increase my X holdings" ‚Üí use add_more_stock with symbol X
  
  **Symbol Extraction Rules:**
  1. If user says "add 5 MORE shares of TSLA" ‚Üí symbol is "TSLA" (explicitly stated)
  2. If user says "add 5 more" ‚Üí symbol is the last stock mentioned in conversation
  3. If user says "buy MORE AAPL" ‚Üí symbol is "AAPL" (comes after MORE)
  4. NEVER extract "MORE" as a symbol - it's a command modifier!

- add_cash: { name: "Main Checking", bank: "Wells Fargo", balance: 5000.00, type: "Checking", apy: 0.01 }
  üìå Use for: "add cash account", "new checking account", "open bank account"
  
- add_savings: { name: "Emergency Fund", bank: "Ally Bank", balance: 10000.00, apy: 4.5 }
  üìå Use for: "add savings account", "open savings", "high-yield savings"
  
- add_property: { name: "Main Residence", propertyType: "House", currentValue: 450000.00, purchasePrice: 400000.00, loanAmount: 300000.00, address: "123 Main St", monthlyRent: 0 }
  üìå Use for: "add property", "buy house", "add real estate"
  
- add_trading_position: { symbol: "AAPL", size: 100, entryPrice: 150.00, type: "Long", broker: "TD Ameritrade" }
  üìå Use for: "open trading position", "add trade", "new position"
  
- add_item / add_valuable_item: { name: "Rolex Watch", category: "Jewelry", currentValue: 15000.00, purchasePrice: 12000.00, condition: "Excellent", notes: "" }
  üìå Use for: "add valuable item", "add collectible", "add luxury item"
  
- update_balance: { accountType: "cash" | "savings", accountName: "Wells Fargo", newBalance: 5000.00 }
- delete_stock: { id: "stock_id" }
- delete_crypto: { id: "crypto_id" }

**üö® CRITICAL - Amount/Number Extraction Rules üö®**
‚ö†Ô∏è **ABSOLUTE RULE: NEVER MULTIPLY OR MODIFY AMOUNTS - USE EXACT VALUES AS STATED** ‚ö†Ô∏è

**MANDATORY CONVERSION TABLE - MEMORIZE THIS:**
| User Says | You Extract | NOT | NEVER |
|-----------|-------------|-----|-------|
| "1k" | 1000 | 100000 | 10000 |
| "2k" | 2000 | 200000 | 20000 |
| "3k" | 3000 | 300000 | 30000 |
| "5k" | 5000 | 500000 | 50000 |
| "10k" | 10000 | 1000000 | 100000 |
| "1000" | 1000 | 100000 | 10000 |
| "3000" | 3000 | 300000 | 30000 |
| "10" | 10 | 100 | 1000 |
| "0.5" | 0.5 | 5 | 50 |
| "0.1" | 0.1 | 1 | 10 |

**STEP-BY-STEP EXTRACTION PROCESS:**
1. Find the number the user stated (e.g., "1k", "3000", "10 shares")
2. Convert "k" notation: 1k = 1000, 2k = 2000, etc.
3. Remove commas from prices: "$45,000" = 45000
4. Use the EXACT number - DO NOT multiply, divide, or modify in any way
5. Double-check: Is this the exact value the user stated? If yes, proceed. If no, STOP and recheck.

**CRITICAL EXAMPLES - LEARN THESE:**
‚úÖ CORRECT:
- User: "add 1k USDT" ‚Üí amount: 1000
- User: "add 3000 USDT" ‚Üí amount: 3000
- User: "buy 5k USDC" ‚Üí amount: 5000
- User: "add 10 shares of AAPL" ‚Üí shares: 10
- User: "add 0.1 BTC" ‚Üí amount: 0.1
- User: "buy 100 USDT" ‚Üí amount: 100

‚ùå WRONG (DO NOT DO THIS):
- User: "add 1k USDT" ‚Üí amount: 100000 ‚ùå (This is multiplying by 100!)
- User: "add 3000 USDT" ‚Üí amount: 300000 ‚ùå (This is multiplying by 100!)
- User: "add 10 shares" ‚Üí shares: 1000 ‚ùå (This is multiplying by 100!)
- User: "add 0.5 BTC" ‚Üí amount: 50 ‚ùå (This is multiplying by 100!)

**VALIDATION CHECK BEFORE RESPONDING:**
Before creating any action JSON, ask yourself:
1. What number did the user say? (e.g., "1k" or "3000")
2. What is the correct conversion? (e.g., "1k" = 1000)
3. Did I multiply or modify this number in any way? IF YES ‚Üí WRONG, FIX IT
4. Is my extracted value exactly what the user meant? IF NO ‚Üí WRONG, FIX IT

**IF IN DOUBT:** Extract the EXACT number as stated. Never assume multiplication is needed.

**Important:** 
- Always extract ALL required fields for actions (symbol, amount/shares, entryPrice)
- Use "entryPrice" for the purchase price (NOT "price" or "buyPrice")
- Always consider the user's existing holdings and context when providing advice
- Be proactive and smart - don't just wait for explicit commands`;

    return prompt;
  }

  /**
   * Pre-parse user input to extract exact numbers (intercept before AI can fuck it up)
   */
  private preParseUserInput(userMessage: string): { shares?: number; amount?: number; price?: number; symbol?: string } | null {
    const msg = userMessage.toLowerCase();
    
    // Pattern: "add/buy X shares of SYMBOL at $Y"
    const stockPattern = /(?:add|buy)\s+(\d+)\s+shares?\s+of\s+([a-z]+)(?:\s+at\s+\$?(\d+(?:\.\d+)?))?/i;
    const stockMatch = userMessage.match(stockPattern);
    
    if (stockMatch) {
      const shares = parseInt(stockMatch[1]);
      const symbol = stockMatch[2].toUpperCase();
      const price = stockMatch[3] ? parseFloat(stockMatch[3]) : undefined;
      
      console.log('üéØ PRE-PARSED STOCK INPUT:', { shares, symbol, price });
      return { shares, symbol, price };
    }
    
    // Pattern: "add/buy X CRYPTO at $Y"
    const cryptoPattern = /(?:add|buy)\s+([\d.]+)\s+([a-z]+)(?:\s+at\s+\$?(\d+(?:\.\d+)?))?/i;
    const cryptoMatch = userMessage.match(cryptoPattern);
    
    if (cryptoMatch && !stockMatch) {
      const amount = parseFloat(cryptoMatch[1]);
      const symbol = cryptoMatch[2].toUpperCase();
      const price = cryptoMatch[3] ? parseFloat(cryptoMatch[3]) : undefined;
      
      console.log('üéØ PRE-PARSED CRYPTO INPUT:', { amount, symbol, price });
      return { amount, symbol, price };
    }
    
    return null;
  }

  /**
   * Process a user message with full context awareness
   */
  async processMessage(userMessage: string): Promise<AIResponse> {
    try {
      // üö® PRE-PARSE to extract exact numbers BEFORE AI can mess them up
      const preParsed = this.preParseUserInput(userMessage);
      
      // Check if this is a market analysis request
      const marketAnalysisRequest = this.detectMarketAnalysisRequest(userMessage);
      
      if (marketAnalysisRequest) {
        return await this.handleMarketAnalysisRequest(marketAnalysisRequest);
      }

      // Wait for model initialization if needed
      if (!this.model) {
        await this.initializeModel();
      }

      // Add user message to context
      this.context.previousMessages.push({
        role: 'user',
        content: userMessage,
      });

      // Build conversation history
      const conversationHistory = this.context.previousMessages
        .slice(-10) // Keep last 10 messages for context
        .map(msg => `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`)
        .join('\n\n');

      // Generate system prompt with financial context
      const systemPrompt = this.generateSystemPrompt();

      // Create the full prompt
      const fullPrompt = `${systemPrompt}

**Conversation History:**
${conversationHistory}

**Current Request:** ${userMessage}

Please respond naturally and intelligently. If this is an action request, include the action JSON. Otherwise, just provide a helpful response.`;

      // Generate response using REST API fallback if SDK fails
      let responseText = '';
      
      try {
        console.log('ü§ñ Calling Gemini API...');
        const result = await this.model.generateContent(fullPrompt);
        const response = await result.response;
        responseText = response.text();
        console.log('‚úÖ Gemini API response received:', responseText.substring(0, 100) + '...');
      } catch (modelError: any) {
        console.warn('‚ö†Ô∏è SDK failed, trying REST API fallback...', modelError.message);
        responseText = await this.callGeminiRestAPI(fullPrompt);
      }

      // Parse action if present
      let action = undefined;
      let needsConfirmation = false;
      let confidence = 0.9;

      // Try to extract JSON action from response
      const jsonMatch = responseText.match(/\{[\s\S]*"action"[\s\S]*\}/);
      if (jsonMatch) {
        try {
          console.log('üîç GEMINI RAW JSON RESPONSE:', jsonMatch[0]);
          const parsed = JSON.parse(jsonMatch[0]);
          console.log('üîç PARSED ACTION DATA:', JSON.stringify(parsed, null, 2));
          if (parsed.action) {
            action = parsed.action;
            console.log('üîç EXTRACTED ACTION (BEFORE CORRECTION):', JSON.stringify(action, null, 2));
            
            // üö®üö®üö® OVERRIDE WITH PRE-PARSED DATA (this fixes Gemini's fuck-ups)
            if (preParsed) {
              console.log('üéØ OVERRIDING with pre-parsed data:', preParsed);
              
              if (preParsed.shares !== undefined && action.type === 'add_stock') {
                console.log(`üîß FORCING shares: ${action.data.shares} ‚Üí ${preParsed.shares}`);
                action.data.shares = preParsed.shares;
              }
              
              if (preParsed.amount !== undefined && action.type === 'add_crypto') {
                console.log(`üîß FORCING amount: ${action.data.amount} ‚Üí ${preParsed.amount}`);
                action.data.amount = preParsed.amount;
              }
              
              if (preParsed.price !== undefined) {
                console.log(`üîß FORCING entryPrice: ${action.data.entryPrice} ‚Üí ${preParsed.price}`);
                action.data.entryPrice = preParsed.price;
              }
              
              if (preParsed.symbol !== undefined) {
                console.log(`üîß FORCING symbol: ${action.data.symbol} ‚Üí ${preParsed.symbol}`);
                action.data.symbol = preParsed.symbol;
              }
            }
            
            // üö® CRITICAL PRE-CORRECTION: Fix share/amount errors IMMEDIATELY after parsing
            if (action.type === 'add_stock' && action.data?.shares) {
              const originalShares = action.data.shares;
              const price = action.data.entryPrice || 1;
              const totalValue = originalShares * price;
              
              console.log('üîç PRE-CORRECTION CHECK:');
              console.log(`  Original shares: ${originalShares}`);
              console.log(`  Price: $${price}`);
              console.log(`  Total value: $${totalValue.toFixed(2)}`);
              
              // Rule 1: If shares >= 100 and is a clean multiple of 100, it's likely 100x error
              if (originalShares >= 100 && originalShares % 100 === 0) {
                const corrected = originalShares / 100;
                if (corrected >= 1 && corrected <= 100) {
                  console.log(`üîß PRE-CORRECTION: Dividing by 100: ${originalShares} ‚Üí ${corrected}`);
                  action.data.shares = corrected;
                }
              }
              // Rule 2: If shares >= 10 and is a clean multiple of 10, it's likely 10x error
              else if (originalShares >= 10 && originalShares % 10 === 0 && originalShares < 100) {
                const corrected = originalShares / 10;
                if (corrected >= 1 && corrected <= 50) {
                  console.log(`üîß PRE-CORRECTION: Dividing by 10: ${originalShares} ‚Üí ${corrected}`);
                  action.data.shares = corrected;
                }
              }
              
              // Rule 3: Check if total value suggests dollar amount confusion
              // If total value is close to $500, $1000, $2000, $3000, $5000
              const commonAmounts = [500, 1000, 1500, 2000, 3000, 5000];
              for (const amount of commonAmounts) {
                if (Math.abs(totalValue - amount) < amount * 0.1) {
                  // AI probably calculated: shares = dollarAmount / price
                  console.log(`‚ö†Ô∏è PRE-CORRECTION: Total $${totalValue} ‚âà $${amount} (dollar confusion suspected)`);
                  
                  // Most common user input is 1-100 shares
                  // Try dividing by factors to find a reasonable share count
                  for (const divisor of [100, 50, 20, 10, 5, 2]) {
                    const possibleShares = originalShares / divisor;
                    if (Number.isInteger(possibleShares) && possibleShares >= 1 && possibleShares <= 100) {
                      console.log(`üîß PRE-CORRECTION: Dollar confusion fix: ${originalShares} ‚Üí ${possibleShares} (√∑${divisor})`);
                      action.data.shares = possibleShares;
                      break;
                    }
                  }
                  break;
                }
              }
              
              if (action.data.shares !== originalShares) {
                const newTotal = action.data.shares * price;
                console.log('‚úÖ PRE-CORRECTION APPLIED:');
                console.log(`  Old: ${originalShares} shares √ó $${price} = $${totalValue.toFixed(2)}`);
                console.log(`  New: ${action.data.shares} shares √ó $${price} = $${newTotal.toFixed(2)}`);
              }
            }
            
            console.log('üîç EXTRACTED ACTION (AFTER CORRECTION):', JSON.stringify(action, null, 2));
            responseText = parsed.message || responseText.replace(jsonMatch[0], '').trim();
            needsConfirmation = true;
          }
        } catch (e) {
          console.error('‚ùå Failed to parse JSON from Gemini:', e);
          // Not valid JSON, continue with text response
        }
      }

      // Add assistant response to context
      this.context.previousMessages.push({
        role: 'assistant',
        content: responseText,
      });

      return {
        text: responseText,
        action,
        confidence,
        needsConfirmation,
      };
    } catch (error: any) {
      console.error('‚ùå Gemini API error:', error);
      console.error('Error details:', {
        message: error?.message,
        status: error?.status,
        statusText: error?.statusText,
      });
      
      // More helpful error messages
      let errorMessage = "I'm having trouble connecting to the AI service. ";
      
      if (error?.message?.includes('API key')) {
        errorMessage = "The API key seems to be invalid. Please check your NEXT_PUBLIC_GOOGLE_AI_API_KEY in .env.local";
      } else if (error?.message?.includes('quota') || error?.status === 429) {
        errorMessage = "API rate limit reached. Please wait a moment and try again.";
      } else if (error?.message?.includes('SAFETY')) {
        errorMessage = "The AI filtered the response for safety. Try rephrasing your question.";
      } else {
        errorMessage += `Error: ${error?.message || 'Unknown error'}. Please try again.`;
      }
      
      return {
        text: errorMessage,
        confidence: 0,
        needsConfirmation: false,
      };
    }
  }

  /**
   * Resolve asset name or partial name to ticker symbol
   */
  private resolveAssetSymbol(input: string): string | null {
    // First, check if it's already a valid symbol (2-5 characters, all caps)
    const upperInput = input.toUpperCase();
    if (upperInput.length >= 2 && upperInput.length <= 5 && /^[A-Z]+$/.test(upperInput)) {
      const instrument = tradingDatabase.find(i => i.symbol === upperInput);
      if (instrument) return instrument.symbol;
    }

    // Try fuzzy matching on asset names
    const searchResults = searchInstruments(input);
    if (searchResults.length > 0) {
      // Prioritize exact name matches
      const exactMatch = searchResults.find(
        i => i.name.toLowerCase() === input.toLowerCase()
      );
      if (exactMatch) return exactMatch.symbol;
      
      // Check if name starts with the input
      const startsWithMatch = searchResults.find(
        i => i.name.toLowerCase().startsWith(input.toLowerCase())
      );
      if (startsWithMatch) return startsWithMatch.symbol;
      
      // Return first result if found
      return searchResults[0].symbol;
    }
    
    // If still not found, try common name mappings
    const commonMappings: Record<string, string> = {
      // Cryptocurrencies
      'bitcoin': 'BTC',
      'ethereum': 'ETH',
      'dogecoin': 'DOGE',
      'cardano': 'ADA',
      'solana': 'SOL',
      'ripple': 'XRP',
      'binance coin': 'BNB',
      'litecoin': 'LTC',
      'polkadot': 'DOT',
      'chainlink': 'LINK',
      'polygon': 'MATIC',
      
      // Stablecoins
      'tether': 'USDT',
      'usd tether': 'USDT',
      'usd coin': 'USDC',
      'usdc': 'USDC',
      'usdt': 'USDT',
      'dai': 'DAI',
      'dai stablecoin': 'DAI',
      'binance usd': 'BUSD',
      'busd': 'BUSD',
      'true usd': 'TUSD',
      'tusd': 'TUSD',
      'pax dollar': 'USDP',
      'usdp': 'USDP',
      
      // Stocks
      'apple': 'AAPL',
      'microsoft': 'MSFT',
      'google': 'GOOGL',
      'alphabet': 'GOOGL',
      'amazon': 'AMZN',
      'tesla': 'TSLA',
      'meta': 'META',
      'facebook': 'META',
      'netflix': 'NFLX',
      'nvidia': 'NVDA',
      
      // Commodities
      'gold': 'GC',
      'silver': 'SI',
      'oil': 'CL',
      'crude oil': 'CL',
      
      // Indices
      's&p 500': 'SPX',
      's&p': 'SPX',
      'dow': 'DJI',
      'dow jones': 'DJI',
      'nasdaq': 'NDX',
    };
    
    const lowerInput = input.toLowerCase().trim();
    return commonMappings[lowerInput] || null;
  }

  /**
   * Detect if user is requesting market analysis
   */
  private detectMarketAnalysisRequest(message: string): any {
    const lowerMsg = message.toLowerCase();
    
    // Technical indicator patterns (RSI, MACD, etc.)
    const indicatorPatterns = [
      /(?:show|display|pull up|get|fetch|analyze)\s+(?:the\s+)?(?:rsi|relative strength index)(?:\s+chart)?(?:\s+for)?(?:\s+)([a-z0-9\s]+?)(?:\s|$)/i,
      /([a-z0-9\s]+?)\s+(?:rsi|relative strength index)(?:\s+chart)?/i,
      /(?:show|display|pull up|get|fetch|analyze)\s+(?:the\s+)?(?:macd)(?:\s+chart)?(?:\s+for)?(?:\s+)([a-z0-9\s]+?)(?:\s|$)/i,
      /([a-z0-9\s]+?)\s+(?:macd)(?:\s+chart)?/i,
      /(?:show|display|pull up|get|fetch|analyze)\s+(?:the\s+)?(?:bollinger bands?)(?:\s+chart)?(?:\s+for)?(?:\s+)([a-z0-9\s]+?)(?:\s|$)/i,
      /([a-z0-9\s]+?)\s+(?:bollinger bands?)(?:\s+chart)?/i,
    ];
    
    for (const pattern of indicatorPatterns) {
      const match = message.match(pattern);
      if (match && match[1]) {
        const assetInput = match[1].trim();
        const symbol = this.resolveAssetSymbol(assetInput);
        if (symbol) {
          // Detect which indicator
          let indicator = 'RSI';
          if (lowerMsg.includes('macd')) indicator = 'MACD';
          else if (lowerMsg.includes('bollinger')) indicator = 'BB';
          
          return { type: 'indicator', symbols: [symbol], indicator };
        }
      }
    }
    
    // Asset analysis patterns (support both tickers and names)
    const assetPatterns = [
      /(?:analyze|analysis|tell me about|what's|whats|how is|hows|info on|information about|check|show me|dive into|let's dive into|give me analysis on)\s+([a-z0-9\s]+?)(?:\s+price|\s+chart|\s+data|\s+analysis|\?|!|$)/i,
      /^([a-z0-9]+?)(?:\s+price|\s+chart|\s+data|\s+analysis)?$/i,
    ];
    
    for (const pattern of assetPatterns) {
      const match = message.match(pattern);
      if (match && match[1]) {
        const assetInput = match[1].trim();
        const symbol = this.resolveAssetSymbol(assetInput);
        if (symbol) {
          return { type: 'asset', symbols: [symbol] };
        }
      }
    }
    
    // Comparison patterns (support both tickers and names)
    const comparePatterns = [
      /compare\s+([a-z0-9\s]+?)\s+(?:and|vs|versus|with|to)\s+([a-z0-9\s]+?)(?:\s|$|\?)/i,
      /([a-z0-9\s]+?)\s+vs\.?\s+([a-z0-9\s]+?)(?:\s|$|\?)/i,
    ];
    
    for (const pattern of comparePatterns) {
      const match = message.match(pattern);
      if (match && match[1] && match[2]) {
        const symbol1 = this.resolveAssetSymbol(match[1].trim());
        const symbol2 = this.resolveAssetSymbol(match[2].trim());
        if (symbol1 && symbol2) {
          return { 
            type: 'compare', 
            symbols: [symbol1, symbol2] 
          };
        }
      }
    }
    
    // Market sentiment patterns
    if (lowerMsg.includes('market sentiment') || 
        lowerMsg.includes('how is the market') ||
        lowerMsg.includes('market overview') ||
        lowerMsg.includes('market condition')) {
      
      if (lowerMsg.includes('crypto')) {
        return { type: 'sentiment', category: 'crypto' };
      } else if (lowerMsg.includes('stock')) {
        return { type: 'sentiment', category: 'stock' };
      } else {
        return { type: 'sentiment', category: 'overall' };
      }
    }
    
    // Portfolio analysis patterns
    if (lowerMsg.includes('portfolio') && 
        (lowerMsg.includes('analyze') || 
         lowerMsg.includes('performance') || 
         lowerMsg.includes('how is my'))) {
      return { type: 'portfolio' };
    }
    
    return null;
  }

  /**
   * Handle market analysis requests
   */
  private async handleMarketAnalysisRequest(request: any): Promise<AIResponse> {
    try {
      let marketData: MarketDataResponse;
      
      switch (request.type) {
        case 'indicator':
          marketData = await AIMarketDataService.fetchTechnicalIndicator(
            request.symbols[0],
            request.indicator
          );
          break;
          
        case 'asset':
          marketData = await AIMarketDataService.fetchAssetInsights(request.symbols[0]);
          break;
          
        case 'compare':
          marketData = await AIMarketDataService.compareAssets(request.symbols);
          break;
          
        case 'sentiment':
          marketData = await AIMarketDataService.getMarketSentiment(request.category);
          break;
          
        case 'portfolio':
          // Get user's holdings
          const [stocks, crypto] = await Promise.all([
            SupabaseDataService.getStockHoldings([]),
            SupabaseDataService.getCryptoHoldings([]),
          ]);
          const allHoldings = [...stocks, ...crypto];
          marketData = await AIMarketDataService.analyzePortfolio(allHoldings);
          break;
          
        default:
          return {
            text: "I'm not sure what market analysis you're looking for. Try asking about a specific asset (e.g., 'analyze BTC'), compare assets ('compare AAPL vs MSFT'), or ask about market sentiment.",
            confidence: 0.5,
            needsConfirmation: false,
          };
      }
      
      // Return clean response without any JSON or extra formatting
      return {
        text: marketData.text,
        marketData,
        charts: marketData.charts,
        confidence: 0.95,
        needsConfirmation: false,
      };
    } catch (error) {
      console.error('Error handling market analysis:', error);
      return {
        text: "I encountered an error fetching market data. Please try again.",
        confidence: 0,
        needsConfirmation: false,
      };
    }
  }

  /**
   * Execute an action returned by the AI
   */
  async executeAction(action: { type: string; data: any }): Promise<{ success: boolean; message: string }> {
    try {
      console.log('üéØ Executing action:', action.type, 'with data:', JSON.stringify(action.data));
      
      switch (action.type) {
        case 'add_stock':
          console.log('üîç RAW stock data received:', JSON.stringify(action.data, null, 2));
          
          // üö® VALIDATION: Check if AI mistakenly extracted "MORE" or other keywords as symbol
          const invalidStockSymbols = ['MORE', 'DUDE', 'YES', 'THAT', 'IT', 'THEM', 'THIS', 'SOME', 'ANY'];
          if (invalidStockSymbols.includes(action.data.symbol?.toUpperCase())) {
            console.error(`‚ùå AI PARSING ERROR: Extracted "${action.data.symbol}" as stock symbol - this is a conversational word, not a ticker!`);
            return {
              success: false,
              message: `‚ùå Oops! I couldn't identify which stock you want to add. Please specify the stock symbol clearly, like: "add ${action.data.shares} shares of TSLA at $${action.data.entryPrice || '200'}"`,
            };
          }
          
          // üö® CRITICAL FIX: Check if stock already exists FIRST
          const existingStocks = await SupabaseDataService.getStockHoldings([]);
          const existingStock = existingStocks.find((s: any) => 
            s.symbol.toUpperCase() === action.data.symbol.toUpperCase()
          );
          
          if (existingStock) {
            console.log(`‚ö†Ô∏è STOCK ${action.data.symbol} ALREADY EXISTS - this would create a duplicate!`);
            console.log(`   Existing: ${existingStock.shares} shares @ $${existingStock.entryPoint}`);
            console.log(`   User wants to add: ${action.data.shares} shares @ $${action.data.entryPrice}`);
            
            return {
              success: false,
              message: `‚ö†Ô∏è You already have ${existingStock.shares} shares of ${action.data.symbol} in your portfolio.\n\nTo add more shares, please say: "add ${action.data.shares} MORE shares of ${action.data.symbol}"\nTo replace your position, please say: "update my ${action.data.symbol} position to ${action.data.shares} shares at $${action.data.entryPrice}"`,
            };
          }
          
          // CRITICAL VALIDATION: Use EXACT share count from AI
          let shares = action.data.shares;
          const stockEntryPrice = action.data.entryPrice;
          
          console.log(`üìä RAW INPUT: ${shares} shares √ó $${stockEntryPrice} = $${(shares * stockEntryPrice).toFixed(2)} total value`);
          
          // üö® ONLY CORRECT IF SHARES >= 100 (protects small share counts like 5, 10, 25)
          // This prevents false positives where 5 shares gets divided incorrectly
          
          if (shares >= 100) {
            console.log(`‚ö†Ô∏è Large share count detected: ${shares} shares - checking for multiplication errors...`);
            
            const totalValue = shares * stockEntryPrice;
            
            // Check if this looks like a 100x error (e.g., 500 shares when user meant 5)
            const dividedBy100 = shares / 100;
            if (Number.isInteger(dividedBy100) && dividedBy100 >= 1 && dividedBy100 <= 100) {
              const correctedTotal = dividedBy100 * stockEntryPrice;
              console.log(`üîç Testing √∑100: ${shares} ‚Üí ${dividedBy100} shares ($${totalValue.toFixed(2)} ‚Üí $${correctedTotal.toFixed(2)})`);
              
              // Only correct if the corrected total makes more sense (e.g., $1000 instead of $100,000)
              if (totalValue >= 10000 && correctedTotal <= 5000) {
                console.log(`‚úÖ CORRECTED 100x error: ${shares} ‚Üí ${dividedBy100} shares`);
                shares = dividedBy100;
                action.data.shares = shares;
              }
            }
            // Check if this looks like a 10x error
            else {
              const dividedBy10 = shares / 10;
              if (Number.isInteger(dividedBy10) && dividedBy10 >= 1 && dividedBy10 <= 100) {
                const correctedTotal = dividedBy10 * stockEntryPrice;
                console.log(`üîç Testing √∑10: ${shares} ‚Üí ${dividedBy10} shares ($${totalValue.toFixed(2)} ‚Üí $${correctedTotal.toFixed(2)})`);
                
                // Only correct if the corrected total makes more sense
                if (totalValue >= 1000 && correctedTotal <= 2000) {
                  console.log(`‚úÖ CORRECTED 10x error: ${shares} ‚Üí ${dividedBy10} shares`);
                  shares = dividedBy10;
                  action.data.shares = shares;
                }
              }
            }
          } else {
            // For small share counts (< 100), TRUST THE AI - DO NOT MODIFY
            console.log(`‚úÖ Small share count (${shares}) - using as-is (NO CORRECTION)`);
          }
          
          // Fetch current market data with real-time price and color
          console.log(`üîç Fetching live market data for ${action.data.symbol}...`);
          const stockMarketData = await enhancedMarketService.fetchAssetPrice(action.data.symbol, 'stock');
          
          let stockCurrentPrice = action.data.currentPrice || action.data.entryPrice;
          let stockName = action.data.symbol;
          let stockColor = '#8b5cf6'; // Default purple fallback
          
          if (stockMarketData) {
            stockCurrentPrice = stockMarketData.currentPrice;
            stockName = stockMarketData.name;
            stockColor = stockMarketData.color;
            console.log(`‚úÖ Got live data: ${stockName} @ $${stockCurrentPrice.toFixed(2)} (${stockColor})`);
          } else {
            stockColor = getAssetColor(action.data.symbol, 'stock');
            console.log(`‚ö†Ô∏è Using fallback data for ${stockName}`);
          }
          
          // FINAL VALIDATION LOG before saving
          const finalTotalValue = action.data.shares * action.data.entryPrice;
          console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
          console.log('üìã FINAL STOCK DATA TO BE SAVED:');
          console.log(`  Symbol: ${action.data.symbol}`);
          console.log(`  Name: ${stockName}`);
          console.log(`  Shares: ${action.data.shares}`);
          console.log(`  Entry Price: $${action.data.entryPrice.toFixed(2)}`);
          console.log(`  Current Price: $${stockCurrentPrice.toFixed(2)}`);
          console.log(`  Total Investment: ${action.data.shares} √ó $${action.data.entryPrice.toFixed(2)} = $${finalTotalValue.toFixed(2)}`);
          console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
          
          await SupabaseDataService.saveStockHolding({
            id: `stock_${Date.now()}`,
            symbol: action.data.symbol,
            name: stockName,
            shares: action.data.shares,
            entryPoint: action.data.entryPrice,
            currentPrice: stockCurrentPrice,
            type: action.data.type || 'Long Term',
            color: stockColor,
          });
          
          // Notify all components that stock data has changed
          if (typeof window !== 'undefined') {
            window.dispatchEvent(new Event('stockDataChanged'));
          }
          
          const stockGainLoss = (stockCurrentPrice - action.data.entryPrice) * action.data.shares;
          const stockGainLossPercent = ((stockCurrentPrice - action.data.entryPrice) / action.data.entryPrice) * 100;
          
          return {
            success: true,
            message: `‚úÖ Successfully added ${action.data.shares} shares of ${action.data.symbol} (${stockName})!\n\nüí∞ Entry: $${action.data.entryPrice.toFixed(2)}\nüìà Current: $${stockCurrentPrice.toFixed(2)}\n${stockGainLoss >= 0 ? 'üü¢' : 'üî¥'} P/L: ${stockGainLoss >= 0 ? '+' : ''}$${stockGainLoss.toFixed(2)} (${stockGainLossPercent >= 0 ? '+' : ''}${stockGainLossPercent.toFixed(2)}%)`,
          };

        case 'update_stock':
          const stocks = await SupabaseDataService.getStockHoldings([]);
          const stockToUpdate = stocks.find((s: any) => 
            s.id === action.data.id || s.symbol === action.data.symbol
          );
          if (stockToUpdate) {
            await SupabaseDataService.saveStockHolding({
              ...stockToUpdate,
              ...action.data.updates,
            });
            
            // Notify all components that stock data has changed
            if (typeof window !== 'undefined') {
              window.dispatchEvent(new Event('stockDataChanged'));
            }
            
            return {
              success: true,
              message: `‚úÖ Successfully updated ${action.data.symbol || 'stock'}!`,
            };
          }
          return {
            success: false,
            message: `‚ùå Could not find the stock to update.`,
          };

        case 'add_more_stock':
          // üö® VALIDATION: Check if AI mistakenly extracted "MORE" or other keywords as symbol
          const invalidSymbols = ['MORE', 'DUDE', 'YES', 'THAT', 'IT', 'THEM', 'THIS'];
          if (invalidSymbols.includes(action.data.symbol?.toUpperCase())) {
            console.error(`‚ùå AI PARSING ERROR: Extracted "${action.data.symbol}" as stock symbol - this is a conversational word, not a ticker!`);
            return {
              success: false,
              message: `‚ùå Oops! I got confused about which stock you're referring to. Please specify the stock symbol clearly, like: "add ${action.data.shares} more shares of TSLA at $${action.data.entryPrice || '200'}"`,
            };
          }
          
          // Add more shares to existing stock position
          const existingStocksToAddTo = await SupabaseDataService.getStockHoldings([]);
          const existingStockToAddTo = existingStocksToAddTo.find((s: any) => 
            s.symbol.toUpperCase() === action.data.symbol.toUpperCase()
          );
          
          if (!existingStockToAddTo) {
            return {
              success: false,
              message: `‚ùå You don't have any ${action.data.symbol} shares to add to. Try "add ${action.data.shares} shares of ${action.data.symbol}" instead.`,
            };
          }
          
          console.log(`üìä Adding ${action.data.shares} MORE shares to existing ${existingStockToAddTo.shares} shares of ${action.data.symbol}`);
          
          // Calculate new weighted average entry price
          const existingCostBasis = existingStockToAddTo.shares * existingStockToAddTo.entryPoint;
          const newCostBasis = action.data.shares * action.data.entryPrice;
          const totalShares = existingStockToAddTo.shares + action.data.shares;
          const newAvgEntryPrice = (existingCostBasis + newCostBasis) / totalShares;
          
          console.log(`  Old position: ${existingStockToAddTo.shares} shares @ $${existingStockToAddTo.entryPoint} = $${existingCostBasis.toFixed(2)}`);
          console.log(`  New purchase: ${action.data.shares} shares @ $${action.data.entryPrice} = $${newCostBasis.toFixed(2)}`);
          console.log(`  Total position: ${totalShares} shares @ $${newAvgEntryPrice.toFixed(2)} average = $${(existingCostBasis + newCostBasis).toFixed(2)}`);
          
          // Update the existing stock with new share count and average price
          await SupabaseDataService.saveStockHolding({
            ...existingStockToAddTo,
            shares: totalShares,
            entryPoint: newAvgEntryPrice,
          });
          
          // Notify all components that stock data has changed
          if (typeof window !== 'undefined') {
            window.dispatchEvent(new Event('stockDataChanged'));
          }
          
          return {
            success: true,
            message: `‚úÖ Successfully added ${action.data.shares} more shares of ${action.data.symbol}!\n\nüìä Previous: ${existingStockToAddTo.shares} shares @ $${existingStockToAddTo.entryPoint.toFixed(2)}\n‚ûï Added: ${action.data.shares} shares @ $${action.data.entryPrice.toFixed(2)}\nüìà New position: ${totalShares} shares @ $${newAvgEntryPrice.toFixed(2)} average`,
          };

        case 'delete_stock':
          await SupabaseDataService.deleteStockHolding(action.data.id);
          
          // Notify all components that stock data has changed
          if (typeof window !== 'undefined') {
            window.dispatchEvent(new Event('stockDataChanged'));
          }
          
          return {
            success: true,
            message: `‚úÖ Successfully removed the stock position!`,
          };

        case 'add_crypto':
          // Validate required data with detailed error messages
          console.log('üîç RAW action.data received:', JSON.stringify(action.data, null, 2));
          
          if (!action.data) {
            return {
              success: false,
              message: '‚ùå No crypto data provided. Please specify the cryptocurrency symbol, amount, and price.',
            };
          }
          
          if (!action.data.symbol) {
            return {
              success: false,
              message: '‚ùå Missing cryptocurrency symbol. Which crypto would you like to add? (e.g., BTC, ETH, SOL)',
            };
          }
          
          console.log('üîç Amount BEFORE validation:', action.data.amount, 'Type:', typeof action.data.amount);
          
          // CRITICAL VALIDATION: Detect if AI incorrectly multiplied the amount
          let rawAmount = action.data.amount;
          const stablecoins = ['USDT', 'USDC', 'DAI', 'BUSD', 'TUSD', 'USDP'];
          const isStablecoin = stablecoins.includes(action.data.symbol.toUpperCase());
          
          // AUTO-CORRECTION LOGIC:
          // 1. If stablecoin amount is >= 100,000, likely AI multiplied by 100
          // 2. If ANY crypto amount is suspiciously large (>= 10,000), check if dividing by 100 is reasonable
          
          if (isStablecoin && rawAmount >= 100000) {
            // Stablecoin amounts >= 100k are very suspicious
            const correctedAmount = rawAmount / 100;
            console.warn('‚ö†Ô∏è STABLECOIN ERROR DETECTED:', rawAmount, '‚Üí Correcting to:', correctedAmount);
            action.data.amount = correctedAmount;
            rawAmount = correctedAmount;
          } else if (rawAmount >= 50000 && !isStablecoin) {
            // Non-stablecoin: check if amount seems multiplied
            const correctedAmount = rawAmount / 100;
            if (correctedAmount >= 10 && correctedAmount < 10000) {
              console.warn('‚ö†Ô∏è CRYPTO AMOUNT ERROR DETECTED:', rawAmount, '‚Üí Correcting to:', correctedAmount);
              action.data.amount = correctedAmount;
              rawAmount = correctedAmount;
            }
          }
          
          // Keep the original stablecoin warning for edge cases
          if (isStablecoin && rawAmount >= 50000) {
            console.warn('‚ö†Ô∏è STILL LARGE after correction:', rawAmount);
            return {
              success: false,
              message: `‚ö†Ô∏è The amount ${rawAmount} ${action.data.symbol} seems unusually high. Please confirm: Did you mean to add ${rawAmount} ${action.data.symbol}, or perhaps ${rawAmount / 100} ${action.data.symbol}? Please specify the exact amount.`,
            };
          }
          
          if (!action.data.amount || isNaN(action.data.amount) || action.data.amount <= 0) {
            return {
              success: false,
              message: `‚ùå Missing or invalid amount for ${action.data.symbol}. How much ${action.data.symbol} would you like to add?`,
            };
          }
          
          // Check for entry price in multiple possible fields
          const entryPrice = action.data.entryPrice || action.data.price || action.data.buyPrice || action.data.entry_price;
          
          console.log('üîç Entry price extracted:', entryPrice, 'Type:', typeof entryPrice);
          
          if (!entryPrice || isNaN(entryPrice) || entryPrice <= 0) {
            return {
              success: false,
              message: `‚ùå Missing or invalid entry price for ${action.data.symbol}. What price did you buy it at?`,
            };
          }

          // Fetch current market data with real-time price and color
          console.log(`üîç Fetching live market data for ${action.data.symbol}...`);
          const cryptoMarketData = await enhancedMarketService.fetchAssetPrice(action.data.symbol, 'crypto');
          
          let currentPrice = parseFloat(entryPrice);
          let cryptoName = action.data.symbol;
          let cryptoColor = '#f59e0b'; // Default fallback
          
          if (cryptoMarketData) {
            currentPrice = cryptoMarketData.currentPrice;
            cryptoName = cryptoMarketData.name;
            cryptoColor = cryptoMarketData.color;
            console.log(`‚úÖ Got live data: ${cryptoName} @ $${currentPrice.toFixed(2)} (${cryptoColor})`);
          } else {
            // Fallback to trading database
            const cryptoInfo = tradingDatabase.find(
              (item) => item.symbol.toUpperCase() === action.data.symbol.toUpperCase() && item.type === 'crypto'
            );
            if (cryptoInfo) {
              cryptoName = cryptoInfo.name;
            }
            cryptoColor = getAssetColor(action.data.symbol, 'crypto');
            console.log(`‚ö†Ô∏è Using fallback data for ${cryptoName}`);
          }
          
          const finalAmount = parseFloat(action.data.amount);
          const finalEntryPrice = parseFloat(entryPrice);
          
          console.log('üîç FINAL VALUES BEFORE SAVE:');
          console.log('  - Amount:', finalAmount, '(original:', action.data.amount, ')');
          console.log('  - Entry Price:', finalEntryPrice, '(original:', entryPrice, ')');
          console.log('  - Symbol:', action.data.symbol.toUpperCase());
          
          await SupabaseDataService.saveCryptoHolding({
            id: `crypto_${Date.now()}`,
            symbol: action.data.symbol.toUpperCase(),
            name: cryptoName,
            amount: finalAmount,
            entryPoint: finalEntryPrice,
            currentPrice: currentPrice,
            color: cryptoColor,
          });
          
          // Notify all components that crypto data has changed
          if (typeof window !== 'undefined') {
            window.dispatchEvent(new Event('cryptoDataChanged'));
          }
          
          const gainLoss = (currentPrice - finalEntryPrice) * finalAmount;
          const gainLossPercent = ((currentPrice - finalEntryPrice) / finalEntryPrice) * 100;
          
          return {
            success: true,
            message: `‚úÖ Successfully added ${finalAmount} ${action.data.symbol.toUpperCase()} (${cryptoName})!\n\nüí∞ Entry: $${finalEntryPrice.toFixed(2)}\nüìà Current: $${currentPrice.toFixed(2)}\n${gainLoss >= 0 ? 'üü¢' : 'üî¥'} P/L: ${gainLoss >= 0 ? '+' : ''}$${gainLoss.toFixed(2)} (${gainLossPercent >= 0 ? '+' : ''}${gainLossPercent.toFixed(2)}%)`,
          };

        case 'add_cash':
          // Generate a color for the cash account
          const cashColor = action.data.color || getAssetColor(action.data.bank || 'CASH', 'stock');
          
          await SupabaseDataService.saveCashAccount({
            id: `cash_${Date.now()}`,
            name: action.data.name || action.data.bank,
            bank: action.data.bank,
            balance: action.data.balance || 0,
            type: action.data.type || 'Checking',
            apy: action.data.apy || 0,
            color: cashColor,
          });
          
          // Notify all components that cash data has changed
          if (typeof window !== 'undefined') {
            window.dispatchEvent(new Event('cashDataChanged'));
            window.dispatchEvent(new Event('financialDataChanged'));
          }
          
          return {
            success: true,
            message: `‚úÖ Successfully added ${action.data.name || action.data.bank} with $${action.data.balance.toLocaleString()} balance!`,
          };

        case 'add_savings':
          // Generate a color for the savings account
          const savingsColor = action.data.color || getAssetColor(action.data.bank || 'SAVINGS', 'stock');
          
          await SupabaseDataService.saveSavingsAccount({
            id: `savings_${Date.now()}`,
            name: action.data.name,
            bank: action.data.bank,
            balance: action.data.balance || 0,
            apy: action.data.apy || 0,
            color: savingsColor,
          });
          
          // Notify all components that savings data has changed
          if (typeof window !== 'undefined') {
            window.dispatchEvent(new Event('savingsDataChanged'));
            window.dispatchEvent(new Event('financialDataChanged'));
          }
          
          return {
            success: true,
            message: `‚úÖ Successfully added ${action.data.name} savings account with $${action.data.balance.toLocaleString()} balance at ${action.data.apy}% APY!`,
          };

        case 'update_balance':
          if (action.data.accountType === 'cash') {
            const accounts = await SupabaseDataService.getCashAccounts([]);
            const account = accounts.find(a => 
              a.name.toLowerCase().includes(action.data.accountName.toLowerCase())
            );
            if (account) {
              await SupabaseDataService.saveCashAccount({
                ...account,
                balance: action.data.newBalance,
              });
              
              // Notify components
              if (typeof window !== 'undefined') {
                window.dispatchEvent(new Event('cashDataChanged'));
                window.dispatchEvent(new Event('financialDataChanged'));
              }
              
              return {
                success: true,
                message: `‚úÖ Updated ${account.name} balance to $${action.data.newBalance.toLocaleString()}!`,
              };
            }
          } else if (action.data.accountType === 'savings') {
            const accounts = await SupabaseDataService.getSavingsAccounts([]);
            const account = accounts.find(a => 
              a.name.toLowerCase().includes(action.data.accountName.toLowerCase())
            );
            if (account) {
              await SupabaseDataService.saveSavingsAccount({
                ...account,
                balance: action.data.newBalance,
              });
              
              // Notify components
              if (typeof window !== 'undefined') {
                window.dispatchEvent(new Event('savingsDataChanged'));
                window.dispatchEvent(new Event('financialDataChanged'));
              }
              
              return {
                success: true,
                message: `‚úÖ Updated ${account.name} balance to $${action.data.newBalance.toLocaleString()}!`,
              };
            }
          }
          return {
            success: false,
            message: `‚ùå Could not find the account. Please specify the exact account name.`,
          };

        case 'add_property':
          // Generate a color for the property based on type
          const propertyColor = action.data.color || getAssetColor(action.data.propertyType || 'PROPERTY', 'stock');
          
          await SupabaseDataService.saveRealEstate({
            id: `property_${Date.now()}`,
            name: action.data.name,
            propertyType: action.data.propertyType,
            currentValue: action.data.currentValue,
            purchasePrice: action.data.purchasePrice,
            loanAmount: action.data.loanAmount || 0,
            address: action.data.address,
            monthlyRent: action.data.monthlyRent || 0,
            color: propertyColor,
          });
          
          // Notify all components that real estate data has changed
          if (typeof window !== 'undefined') {
            window.dispatchEvent(new Event('realEstateDataChanged'));
            window.dispatchEvent(new Event('financialDataChanged'));
          }
          
          const equity = action.data.currentValue - (action.data.loanAmount || 0);
          const roi = action.data.purchasePrice > 0 
            ? ((action.data.currentValue - action.data.purchasePrice) / action.data.purchasePrice * 100)
            : 0;
          
          return {
            success: true,
            message: `‚úÖ Successfully added property: ${action.data.name}!\n\nüí∞ Current Value: $${action.data.currentValue.toLocaleString()}\nüè¶ Equity: $${equity.toLocaleString()}\nüìà ROI: ${roi >= 0 ? '+' : ''}${roi.toFixed(2)}%`,
          };

        case 'add_trading_position':
          // Generate a color for the trading position
          const tradingColor = action.data.color || getAssetColor(action.data.symbol || 'TRADE', 'stock');
          const positionValue = (action.data.size || 1) * (action.data.entryPrice || 0);
          
          await SupabaseDataService.saveTradingAccount({
            id: `trade_${Date.now()}`,
            name: action.data.symbol || action.data.name,
            broker: action.data.broker || 'Trading Account',
            balance: positionValue,
            type: action.data.type || 'Stocks',
            color: tradingColor,
          });
          
          // Notify all components that trading data has changed
          if (typeof window !== 'undefined') {
            window.dispatchEvent(new Event('tradingDataChanged'));
            window.dispatchEvent(new Event('financialDataChanged'));
          }
          
          return {
            success: true,
            message: `‚úÖ Successfully opened ${action.data.type || 'trading'} position on ${action.data.symbol}!\n\nüí∞ Position Size: ${action.data.size}\nüìà Entry Price: $${action.data.entryPrice}\nüíµ Total Value: $${positionValue.toLocaleString()}`,
          };

        case 'add_item':
        case 'add_valuable_item':
          // Generate a color for the valuable item based on category
          const itemColor = action.data.color || getAssetColor(action.data.category || 'ITEM', 'stock');
          
          await SupabaseDataService.saveValuableItem({
            id: `item_${Date.now()}`,
            name: action.data.name,
            category: action.data.category,
            currentValue: action.data.currentValue || action.data.value,
            purchasePrice: action.data.purchasePrice || action.data.currentValue || action.data.value,
            condition: action.data.condition || 'Excellent',
            notes: action.data.notes || '',
            color: itemColor,
          });
          
          // Notify all components that valuable items data has changed
          if (typeof window !== 'undefined') {
            window.dispatchEvent(new Event('itemsDataChanged'));
            window.dispatchEvent(new Event('financialDataChanged'));
          }
          
          const itemValue = action.data.currentValue || action.data.value;
          const itemCost = action.data.purchasePrice || itemValue;
          const itemGain = itemValue - itemCost;
          
          return {
            success: true,
            message: `‚úÖ Successfully added ${action.data.name} (${action.data.category})!\n\nüí∞ Current Value: $${itemValue.toLocaleString()}\n${itemGain >= 0 ? 'üìà' : 'üìâ'} ${itemGain >= 0 ? 'Appreciation' : 'Depreciation'}: ${itemGain >= 0 ? '+' : ''}$${itemGain.toLocaleString()}`,
          };

        default:
          return {
            success: false,
            message: `‚ùå Unknown action type: ${action.type}`,
          };
      }
    } catch (error) {
      console.error('Error executing action:', error);
      return {
        success: false,
        message: `‚ùå Failed to execute action: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }
  }

  /**
   * Clear conversation context
   */
  clearContext(): void {
    this.context.previousMessages = [];
  }

  /**
   * Get current context statistics
   */
  getContextInfo(): any {
    return {
      messageCount: this.context.previousMessages.length,
      hasFinancialData: !!this.context.financialData,
      userId: this.context.userId,
    };
  }
}
